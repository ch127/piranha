#!/bin/sh

##########################################################################################
#  __  o  __   __   __  |__   __                                                         #
# |__) | |  ' (__( |  ) |  ) (__(                                                        #
# |                                                                                      #
#                                                                                        #
# File: nQuireRunner.sh                                                                  #
  VERSION="v1.0.3"                                                                       #
# Author: Justin C. Bagley                                                               #
# Date: Created by Justin Bagley on Thu, Oct 17 11:59:08 CDT 2019.                       #
# Last update: April 12, 2020                                                            #
# Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved.                         #
# Please report bugs to <bagleyj@umsl.edu>.                                              #
#                                                                                        #
# Description:                                                                           #
# SHELL SCRIPT THAT AUTOMATES RUNNING nQuire TO DETERMINE SAMPLE PLOIDY LEVEL FROM NGS   #
# READS FOR ONE OR MULTIPLE SAMPLES, STARTING FROM BAM FILE(S) FOR THE SAMPLE(S)         #
#                                                                                        #
##########################################################################################

# Provide a variable with the location of this script.
SCRIPT_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Source Scripting Utilities
# -----------------------------------
# These shared utilities provide many functions which are needed to provide
# the functionality in this boilerplate. This script will fail if they can
# not be found.
# -----------------------------------

UTILS_LOCATION="${SCRIPT_PATH}/../lib/utils.sh" # Update this path to find the utilities.

if [[ -f "${UTILS_LOCATION}" ]]; then
  source "${UTILS_LOCATION}"
else
  echo "Please find the file util.sh and add a reference to it in this script. Exiting..."
  exit 1
fi


# Source shared functions and variables
# -----------------------------------

FUNCS_LOCATION="${SCRIPT_PATH}/../lib/sharedFunctions.sh" # Update this path to find the shared functions.
VARS_LOCATION="${SCRIPT_PATH}/../lib/sharedVariables.sh" # Update this path to find the shared variables.

if [[ -f "${FUNCS_LOCATION}" ]] && [[ -f "${VARS_LOCATION}" ]]; then
  source "${FUNCS_LOCATION}" ;
  source "${VARS_LOCATION}" ;
else
  echo "Please find the files sharedFunctions.sh and sharedVariables.sh and add references to them in this script. Exiting... "
  exit 1
fi


# trapCleanup Function
# -----------------------------------
# Any actions that should be taken if the script is prematurely
# exited.  Always call this function at the top of your script.
# -----------------------------------
trapCleanup () {
  echo ""
  # Delete temp files, if any
  if is_dir "${tmpDir}"; then
    rm -r "${tmpDir}"
  fi
  die "Exit trapped. In function: '${FUNCNAME[*]}'"
}

# safeExit
# -----------------------------------
# Non destructive exit for when script exits naturally.
# Usage: Add this function at the end of every script.
# -----------------------------------
safeExit () {
  # Delete temp files, if any
  if is_dir "${tmpDir}"; then
    rm -r "${tmpDir}"
  fi
  trap - INT TERM EXIT
  exit
}

# Set Flags
# -----------------------------------
# Flags which can be overridden by user input.
# Default values are below
# -----------------------------------
quiet=false
printLog=false
verbose=false
force=false
strict=false
debug=false
args=()

# Set Temp Directory
# -----------------------------------
# Create temp directory with three random numbers and the process ID
# in the name.  This directory is removed automatically at exit.
# -----------------------------------
tmpDir="/tmp/${SCRIPT_NAME}.$RANDOM.$RANDOM.$RANDOM.$$"
(umask 077 && mkdir "${tmpDir}") || {
  die "Could not create temporary directory! Exiting."
}

# Logging
# -----------------------------------
# Log is only used when the '-l' flag is set.
#
# To never save a logfile change variable to '/dev/null'
# Save to Desktop use: $HOME/Desktop/${SCRIPT_BASENAME}.log
# Save to standard user log location use: $HOME/Library/Logs/${SCRIPT_BASENAME}.log
# -----------------------------------
logFile="$HOME/Library/Logs/${SCRIPT_BASENAME}.log"

# Check for Dependencies
# -----------------------------------
# Arrays containing package dependencies needed to execute this script.
# The script will fail if dependencies are not installed.  For Mac users,
# most dependencies can be installed automatically using the package
# manager 'Homebrew'.  Mac applications will be installed using
# Homebrew Casks. Ruby and gems via RVM.
# -----------------------------------
homebrewDependencies=()
caskDependencies=()
gemDependencies=()




nQuireRunner () {

######################################## START ###########################################
##########################################################################################

echo "INFO      | $(date) |----------------------------------------------------------------"
echo "INFO      | $(date) | nQuireRunner, v1.0.3 April 2020                                "
echo "INFO      | $(date) | Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved. "
echo "INFO      | $(date) |----------------------------------------------------------------"

######################################## START ###########################################
	echo "INFO      | $(date) | Starting nQuireRunner pipeline... "
	echo "INFO      | $(date) | Step #1: Set up workspace."

############ STEP #1: SET UP VARIABLES AND USEFUL FUNCTIONS
###### Set working directory and filetypes as different variables:
	echo "INFO      | $(date) |          Setting user-specified path to: "
	echo "INFO      | $(date) |          $PWD "	
	echo "INFO      | $(date) |          Input file: $MY_BAM_FILE "
	echo "INFO      | $(date) |          Examining current directory, setting variables... "

checkMachineType

# USAGE goal:   nQuireRunner.sh $1   ; OR   nQuireRunner -b $1  , where $1 and -b $1 are the input .bam file
# MY_BAM_FILE="$1"

# exec >> ./"$MY_BAM_FILE"_nQuireRunner.out.txt ;
# exec 2>&1 ;


####
####
if [[ "$MY_MULTIBAM_SWITCH" = "0" ]] && [[ -s "$MY_BAM_FILE" ]]; then

############ STEPS #2 & #3: PREP WORK & RUNNING nQuire

	echo "INFO      | $(date) | Step #2: Prep input .bam file for model runs in nQuire... "
	echo "INFO      | $(date) |          Processing .bam file... "
	echo "INFO      | $(date) |             Storing filename... "
	MY_BAM_BASENAME="$(basename "$MY_BAM_FILE" '.bam')";

	echo "INFO      | $(date) |             Creating base file ${MY_BAM_BASENAME}_base.bin... "
	nQuire create -b "$MY_BAM_FILE" -o "$MY_BAM_BASENAME"_base 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	echo "INFO      | $(date) |             Creating base file histogram... "
	nQuire histo "$MY_BAM_BASENAME"_base.bin > "$MY_BAM_BASENAME"_base.bin.histo.txt 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	echo "INFO      | $(date) |             "
	echo "INFO      | $(date) |             Creating denoised base file ${MY_BAM_BASENAME}_base_denoised.bin... "
	nQuire denoise -o "$MY_BAM_BASENAME"_base_denoised "$MY_BAM_BASENAME"_base.bin 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	echo "INFO      | $(date) |             Creating denoised base file histogram... "
	nQuire histo "$MY_BAM_BASENAME"_base_denoised.bin > "$MY_BAM_BASENAME"_base_denoised.bin.histo.txt 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;


	echo "INFO      | $(date) | Step #3: Running nQuire... "
	echo "INFO      | $(date) |          Running lrdmodel on base file, ${MY_BAM_BASENAME}_base.bin, sending output to .out.txt file... "
	nQuire lrdmodel "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	nQuire lrdmodel "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.lrdmodel.out.txt ;

	echo "INFO      | $(date) |             "

	echo "INFO      | $(date) |          Running lrdmodel on denoised base file, ${MY_BAM_BASENAME}_base_denoised.bin, sending output to .out.txt file... "
	nQuire lrdmodel "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	nQuire lrdmodel "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.lrdmodel.out.txt ;


	echo "INFO      | $(date) |          Running tests (modeltest, estmodel, and histotest) on base file, sending output to .out.txt file... "
	nQuire modeltest "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	nQuire estmodel "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	nQuire histotest "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;

	nQuire modeltest "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.modeltest.out.txt ;
	nQuire estmodel "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.estmodel.out.txt ;
	nQuire histotest "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.histotest.out.txt ;

	echo "INFO      | $(date) |             "

	echo "INFO      | $(date) |          Running tests (modeltest, estmodel, and histotest) on denoised base file, sending output to .out.txt file... "
	nQuire modeltest "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	nQuire estmodel "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
	nQuire histotest "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;

	nQuire modeltest "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt ;
	nQuire estmodel "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.estmodel.out.txt ;
	nQuire histotest "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt ;

	echo "INFO      | $(date) |             "


############ STEP #4: POST-PROCESSING OF THE nQuire RESULTS

	echo "INFO      | $(date) | Step #4: Post-processing of nQuire results for ${MY_BAM_FILE}... "

#### Histotest-based (goodness-of-fit-based) ploidy interpretation:

	echo "INFO      | $(date) |             Best ploidy model based on goodness-of-fit... "
	## Find model / ploidy level with positive slope in histotest check files. These will be
	## the best-fit model(s), and should be the same for regular and denoised base.bin files. 
	## Here, we first get the line where the positive slope model is reported in each file. 
	## Next, we figure out the ploidy label line for the corresponding positive slope model. 
	## Then, finally, we echo the filename and ploidy result to screen, and to file. We do
	## the entire procedure for both the regular and denoised base.bin files, as follows:
	MY_POS_SLOPE_LINE="$(grep -n 'slope\:\ [0-9]' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\:\ \ y\-y\ slope\:\ .*\,\ .*\:\ .*//g')";
	MY_CORR_HIST_PLOIDY_LINE="$(calc $MY_POS_SLOPE_LINE-2)";
	echo "INFO      | $(date) |             Best-fit ploidy model from regular base file: "
	sed -n ''"$MY_CORR_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\://g' ; # echoes ploidy to screen
	sed -n ''"$MY_CORR_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\://g' > "$MY_BAM_BASENAME"_base.bin.histotest.PLOIDY.txt ;
#
	MY_DENOISE_POS_SLOPE_LINE="$(grep -n 'slope\:\ [0-9]' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\:\ \ y\-y\ slope\:\ .*\,\ .*\:\ .*//g')";
	MY_CORR_DENOISE_HIST_PLOIDY_LINE="$(calc $MY_DENOISE_POS_SLOPE_LINE-2)";
	echo "INFO      | $(date) |             Best-fit ploidy model from denoised base file: "
	sed -n ''"$MY_CORR_DENOISE_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\://g' ; # echoes ploidy to screen
	sed -n ''"$MY_CORR_DENOISE_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\://g' > "$MY_BAM_BASENAME"_base_denoised.bin.histotest.PLOIDY.txt ;


#### Model test ploidy interpretation:

	echo "INFO      | $(date) |             Best ploidy model based on model testing (log-likelihood comparison) on denoised base file results... "
	MY_DENOISE_DIP_LOGLIKE="$(grep -h 'diploid' "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt | sed 's/[A-Za-z\ \:]//g' | sed 's/\..*//g')";
	MY_DENOISE_TRIP_LOGLIKE="$(grep -h 'triploid' "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt | sed 's/[A-Za-z\ \:]//g' | sed 's/\..*//g')";
	MY_DENOISE_TETRA_LOGLIKE="$(grep -h 'tetraploid' "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt | sed 's/[A-Za-z\ \:]//g' | sed 's/\..*//g')";
	if [[ "$MY_DENOISE_DIP_LOGLIKE" -gt "$MY_DENOISE_TRIP_LOGLIKE" ]] && [[ "$MY_DENOISE_DIP_LOGLIKE" -gt "$MY_DENOISE_TETRA_LOGLIKE" ]]; then MY_MODELTEST_PLOIDY="Diploid"; echo "Diploid"; fi
	if [[ "$MY_DENOISE_TRIP_LOGLIKE" -gt "$MY_DENOISE_DIP_LOGLIKE" ]] && [[ "$MY_DENOISE_TRIP_LOGLIKE" -gt "$MY_DENOISE_TETRA_LOGLIKE" ]]; then MY_MODELTEST_PLOIDY="Triploid"; echo "Triploid"; fi
	if [[ "$MY_DENOISE_TETRA_LOGLIKE" -gt "$MY_DENOISE_DIP_LOGLIKE" ]] && [[ "$MY_DENOISE_TETRA_LOGLIKE" -gt "$MY_DENOISE_TRIP_LOGLIKE" ]]; then MY_MODELTEST_PLOIDY="Tetraploid"; echo "Tetraploid"; fi
	echo "$MY_MODELTEST_PLOIDY" > "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.PLOIDY.txt ;


fi
####
####



####
####
if [[ "$MY_MULTIBAM_SWITCH" = "1" ]]; then

(
	for MY_BAM_FILE in ./*.bam ; do
		
		echo "INFO      | $(date) | #############################  "
		echo "INFO      | $(date) | #############################  Current .bam file: ${MY_BAM_FILE} "
		echo "INFO      | $(date) | #############################  "
		echo "INFO      | $(date) |             "

		############ STEPS #2 & #3: PREP WORK & RUNNING nQuire
		
			echo "INFO      | $(date) | Step #2: Prep input .bam file for model runs in nQuire... "
			echo "INFO      | $(date) |          Processing .bam file... "
			echo "INFO      | $(date) |             Storing filename... "
			MY_BAM_BASENAME="$(basename "$MY_BAM_FILE" '.bam')";

			if [[ -s  "$MY_BAM_BASENAME"_base_denoised.bin ]] && [[ -s "$MY_BAM_BASENAME"_nQuireRunner.out.txt ]] && [[ -s "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt ]]; then
				echo "INFO      | $(date) |             Checking for related files... "
				echo "WARNING!  | $(date) |             File already analyzed by nQuireRunner--SKIPPING!!! "
			fi
		###
			if [[ ! -s  "$MY_BAM_BASENAME"_base_denoised.bin ]] && [[ ! -s "$MY_BAM_BASENAME"_nQuireRunner.out.txt ]]; then

			echo "$MY_BAM_BASENAME" >> ./nQuireRunner_sample_basenames.list.txt ;
			echo "$MY_BAM_FILE" >> ./nQuireRunner_sample_bamfiles.list.txt ;

			echo "INFO      | $(date) |             Creating base file ${MY_BAM_BASENAME}_base.bin... "
			nQuire create -b "$MY_BAM_FILE" -o "$MY_BAM_BASENAME"_base 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			echo "INFO      | $(date) |             Creating base file histogram... "
			nQuire histo "$MY_BAM_BASENAME"_base.bin > "$MY_BAM_BASENAME"_base.bin.histo.txt 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			echo "INFO      | $(date) |             "
			echo "INFO      | $(date) |             Creating denoised base file ${MY_BAM_BASENAME}_base_denoised.bin... "
			nQuire denoise -o "$MY_BAM_BASENAME"_base_denoised "$MY_BAM_BASENAME"_base.bin 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			echo "INFO      | $(date) |             Creating denoised base file histogram... "
			nQuire histo "$MY_BAM_BASENAME"_base_denoised.bin > "$MY_BAM_BASENAME"_base_denoised.bin.histo.txt 2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
		
		
			echo "INFO      | $(date) | Step #3: Running nQuire... "
			echo "INFO      | $(date) |          Running lrdmodel on base file, ${MY_BAM_BASENAME}_base.bin, sending output to .out.txt file... "
			nQuire lrdmodel "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			nQuire lrdmodel "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.lrdmodel.out.txt ;
		
			echo "INFO      | $(date) |             "
		
			echo "INFO      | $(date) |          Running lrdmodel on denoised base file, ${MY_BAM_BASENAME}_base_denoised.bin, sending output to .out.txt file... "
			nQuire lrdmodel "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			nQuire lrdmodel "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.lrdmodel.out.txt ;
		
		
			echo "INFO      | $(date) |          Running tests (modeltest, estmodel, and histotest) on base file, sending output to .out.txt file... "
			nQuire modeltest "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			nQuire estmodel "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			nQuire histotest "$MY_BAM_BASENAME"_base.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
		
			nQuire modeltest "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.modeltest.out.txt ;
			nQuire estmodel "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.estmodel.out.txt ;
			nQuire histotest "$MY_BAM_BASENAME"_base.bin  > "$MY_BAM_BASENAME"_base.bin.histotest.out.txt ;
		
			echo "INFO      | $(date) |             "
		
			echo "INFO      | $(date) |          Running tests (modeltest, estmodel, and histotest) on denoised base file, sending output to .out.txt file... "
			nQuire modeltest "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			nQuire estmodel "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
			nQuire histotest "$MY_BAM_BASENAME"_base_denoised.bin  2>&1 | tee "$MY_BAM_BASENAME"_nQuireRunner.out.txt ;
		
			nQuire modeltest "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt ;
			nQuire estmodel "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.estmodel.out.txt ;
			nQuire histotest "$MY_BAM_BASENAME"_base_denoised.bin  > "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt ;
		
			echo "INFO      | $(date) |             "
		
		
		############ STEP #4: POST-PROCESSING OF THE nQuire RESULTS
		
			echo "INFO      | $(date) | Step #4: Initial post-processing of nQuire results for ${MY_BAM_FILE}... "
		
		#### Histotest-based (goodness-of-fit-based) ploidy interpretation:
		
			echo "INFO      | $(date) |             Best ploidy model based on goodness-of-fit... "
			## Find model / ploidy level with positive slope in histotest check files. These will be
			## the best-fit model(s), and should be the same for regular and denoised base.bin files. 
			## Here, we first get the line where the positive slope model is reported in each file. 
			## Next, we figure out the ploidy label line for the corresponding positive slope model. 
			## Then, finally, we echo the filename and ploidy result to screen, and to file. We do
			## the entire procedure for both the regular and denoised base.bin files, as follows:
			MY_POS_SLOPE_LINE="$(grep -n 'slope\:\ [0-9]' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\:\ \ y\-y\ slope\:\ .*\,\ .*\:\ .*//g')";
			MY_CORR_HIST_PLOIDY_LINE="$(calc $MY_POS_SLOPE_LINE-2)";
			echo "INFO      | $(date) |             Best-fit ploidy model from regular base file: "
			sed -n ''"$MY_CORR_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\://g' ; # echoes ploidy to screen
			sed -n ''"$MY_CORR_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\://g' > "$MY_BAM_BASENAME"_base.bin.histotest.PLOIDY.txt ;
#
			sed -n ''"$MY_CORR_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base.bin.histotest.out.txt | sed 's/\://g' >> nQuireRunner_reg_base_histotest.PLOIDY.list.txt  ;
#
			MY_DENOISE_POS_SLOPE_LINE="$(grep -n 'slope\:\ [0-9]' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\:\ \ y\-y\ slope\:\ .*\,\ .*\:\ .*//g')";
			MY_CORR_DENOISE_HIST_PLOIDY_LINE="$(calc $MY_DENOISE_POS_SLOPE_LINE-2)";
			echo "INFO      | $(date) |             Best-fit ploidy model from denoised base file: "
			sed -n ''"$MY_CORR_DENOISE_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\://g' ; # echoes ploidy to screen
			sed -n ''"$MY_CORR_DENOISE_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\://g' > "$MY_BAM_BASENAME"_base_denoised.bin.histotest.PLOIDY.txt ;
#
			sed -n ''"$MY_CORR_DENOISE_HIST_PLOIDY_LINE"'p' "$MY_BAM_BASENAME"_base_denoised.bin.histotest.out.txt | sed 's/\://g' >> nQuireRunner_denoised_base_histotest.PLOIDY.list.txt  ; 
		
		#### Model test ploidy interpretation:
		
			echo "INFO      | $(date) |             Best ploidy model based on model testing (log-likelihood comparison) on denoised base file results... "
			MY_DENOISE_DIP_LOGLIKE="$(grep -h 'diploid' "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt | sed 's/[A-Za-z\ \:]//g' | sed 's/\..*//g')";
			MY_DENOISE_TRIP_LOGLIKE="$(grep -h 'triploid' "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt | sed 's/[A-Za-z\ \:]//g' | sed 's/\..*//g')";
			MY_DENOISE_TETRA_LOGLIKE="$(grep -h 'tetraploid' "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.out.txt | sed 's/[A-Za-z\ \:]//g' | sed 's/\..*//g')";
			if [[ "$MY_DENOISE_DIP_LOGLIKE" -gt "$MY_DENOISE_TRIP_LOGLIKE" ]] && [[ "$MY_DENOISE_DIP_LOGLIKE" -gt "$MY_DENOISE_TETRA_LOGLIKE" ]]; then MY_MODELTEST_PLOIDY="Diploid"; echo "Diploid"; fi
			if [[ "$MY_DENOISE_TRIP_LOGLIKE" -gt "$MY_DENOISE_DIP_LOGLIKE" ]] && [[ "$MY_DENOISE_TRIP_LOGLIKE" -gt "$MY_DENOISE_TETRA_LOGLIKE" ]]; then MY_MODELTEST_PLOIDY="Triploid"; echo "Triploid"; fi
			if [[ "$MY_DENOISE_TETRA_LOGLIKE" -gt "$MY_DENOISE_DIP_LOGLIKE" ]] && [[ "$MY_DENOISE_TETRA_LOGLIKE" -gt "$MY_DENOISE_TRIP_LOGLIKE" ]]; then MY_MODELTEST_PLOIDY="Tetraploid"; echo "Tetraploid"; fi
			echo "$MY_MODELTEST_PLOIDY" > "$MY_BAM_BASENAME"_base_denoised.bin.modeltest.PLOIDY.txt ;
#
			echo "$MY_MODELTEST_PLOIDY" >> nQuireRunner_denoised_base_modeltest.PLOIDY.list.txt  ;
				
			fi
		###

	done
)


	echo "INFO      | $(date) |             "
	echo "INFO      | $(date) | Step #5: Summarize results and clean up workspace by organizing list and summary files... "
	###### Remove temporary or unnecessary files created above:
	#		echo "INFO      | $(date) |          Removing temporary files... "
	#	rm ./*.tmp ;

	paste ./nQuireRunner_sample_basenames.list.txt nQuireRunner_reg_base_histotest.PLOIDY.list.txt > nQuireRunner_reg_base_histotest.PLOIDY.Summary.txt ;

	paste ./nQuireRunner_sample_basenames.list.txt nQuireRunner_denoised_base_histotest.PLOIDY.list.txt > nQuireRunner_denoised_base_histotest.PLOIDY.Summary.txt ;

	paste ./nQuireRunner_sample_basenames.list.txt nQuireRunner_denoised_base_modeltest.PLOIDY.list.txt > nQuireRunner_denoised_base_modeltest.PLOIDY.Summary.txt ;

	echo " " | sed 's/\ /bam\_file\treg\_base\_histotest\.PLOIDY\tdenoised\_base\_histotest\.PLOIDY\tdenoised\_base\_modeltest\.PLOIDY/g' > header.txt  ;
	paste ./nQuireRunner_sample_basenames.list.txt nQuireRunner_reg_base_histotest.PLOIDY.list.txt nQuireRunner_denoised_base_histotest.PLOIDY.list.txt nQuireRunner_denoised_base_modeltest.PLOIDY.list.txt > nQuireRunner_PLOIDY.Summary.headless.txt ;
	cat header.txt nQuireRunner_PLOIDY.Summary.headless.txt > nQuireRunner_PLOIDY.FINAL.SUMMARY.txt ;

	mkdir misc/;
	mkdir lists/;
	mkdir summaries/;
	
	mv nQuireRunner_PLOIDY.Summary.headless.txt misc/ ;
	mv nQuireRunner_denoised_base_histotest.PLOIDY.list.txt nQuireRunner_denoised_base_modeltest.PLOIDY.list.txt nQuireRunner_reg_base_histotest.PLOIDY.list.txt lists/ ;
	mv nQuireRunner_denoised_base_histotest.PLOIDY.Summary.txt nQuireRunner_denoised_base_modeltest.PLOIDY.Summary.txt nQuireRunner_reg_base_histotest.PLOIDY.Summary.txt summaries/;
	# nQuireRunner_PLOIDY.FINAL.SUMMARY.txt



	fi
	###

fi
####
####

echo "INFO      | $(date) | Step #5: Clean up workspace by removing temporary files generated during run. "
############ CLEAN UP WORKING DIR BY DELETING TEMPORARY FILES.
	echo "INFO      | $(date) |          Removing temporary files... "
	
	if [[ ! -z $(ls ./*.tmp) ]]; then rm ./*.tmp ; fi
	if [[ -s ./args.txt ]]; then rm ./args.txt ; fi 	## Remove arguments file generated when parsing the options.

echo "INFO      | $(date) | Done."
echo "----------------------------------------------------------------------------------------------------------"
# if [[ -s "$MY_NEXUS_BASENAME".charsets.txt ]] && [[ -s "$MY_NEXUS_BASENAME" ]]; then
# 	echo "output files: ./${MY_NEXUS_BASENAME}.phy"
# 	echo "              ./${MY_NEXUS_BASENAME}.charsets.txt"
# else
# 	echo "output file: ./${MY_NEXUS_BASENAME}.phy"
# fi
echo ""

##########################################################################################
######################################### END ############################################

}



############ CREATE USAGE & HELP TEXTS
USAGE="Usage: $(basename "$0") [OPTION]...

 ${bold}Options:${reset}
  -b   inputBAM (def: NULL) for single-BAM run, name of input .bam file from appropriately
       mapping reads to a reference
  -m   multiBAM (def: 0, off; 1, on) run on all .bam files in current working directory
  -h   help text (also: --help) echo this help text and exit
  -H   verbose help text (also: --Help) echo verbose help text and exit
  -V   version (also: --version) echo version and exit

 ${bold}OVERVIEW${reset}
 This function automates running the nQuire software program (Weiß et al. 2018) to estimate 
 sample ploidy levels from next-generation sequencing (NGS; e.g. Illumina) reads for one or 
 multiple samples, starting from BAM file(s) (extension '.bam'; Li et al. 2009) for the 
 sample(s). It is assumed that the .bam input file(s) were output by an aligner such as 
 bwa (Li and Durbin 2009) and contain information on reads mapped to an appropriate 
 reference (draft reference genome, pseudo-reference genome assembly, etc.).
	The standard way to run this function is to feed it the name of a single input .bam 
 file using the -b flag, which will be read in and used to run several models to determine 
 the ploidy level of the corresponding sample (diploid, triploid, or tetraploid are the only 
 possibilities; where higher ploidy levels are possible/suspected, this approach should not 
 be used). By default, the program selectively sends output to screen, and also saves all 
 pertinent output to files prefixed with the basename of the input .bam file.
	The only dependencies for the nQuireRunner function are nQuire, which can be obtained
 from GitHub (available at: https://github.com/clwgg/nQuire), and Perl. This function has
 been tested with Perl v5.1+ on macOS High Sierra (v10.13+) and with Perl under Centos 5/6/7
 Linux.

 ${bold}Usage examples:${reset}
 Call the program using PIrANHA, as follows:

    piranha -f nQuireRunner -i <inputBAM>      Standard run on single .bam file (one sample)
    piranha -f nQuireRunner -m 1               Multi-bam run on all .bam files in working directory

 ${bold}CITATION${reset}
 Bagley, J.C. 2019. PIrANHA v0.3a2. GitHub repository, Available at:
	<https://github.com/justincbagley/PIrANHA>.

 ${bold}REFERENCES${reset}
 Li, H., Durbin, R. 2009. Fast and accurate short read alignment with Burrows–Wheeler 
	transform. Bioinformatics, 25(14), 1754–1760.
 Li, H., Handsaker, B., Wysoker, A., Fennell, T., Ruan, J., Homer, N., Marth, G., Abecasis, 
	G., Durbin, R., 1000 Genome Project Data Processing Subgroup 2009. The sequence 
	Alignment/Map format and SAMtools. Bioinformatics, 25(16), 2078–2079.
 Weiß, C.L., Pais, M., Cano, L.M., Kamoun, S. Burbano, H.A. 2018. nQuire: a statistical 
	framework for ploidy estimation using next generation sequencing. BMC bioinformatics, 
	19(1), 122.
  
 Created by Justin Bagley on Thu, Oct 17 11:59:08 CDT 2019.
 Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved.
"

VERBOSE_USAGE="Usage: $(basename "$0") [OPTION]...

 ${bold}Options:${reset}
  -b   inputBAM (def: NULL) for single-BAM run, name of input .bam file from appropriately
       mapping reads to a reference
  -m   multiBAM (def: 0, off; 1, on) run on all .bam files in current working directory
  -h   help text (also: --help) echo this help text and exit
  -H   verbose help text (also: --Help) echo verbose help text and exit
  -V   version (also: --version) echo version and exit

 ${bold}OVERVIEW${reset}
 This function automates running the nQuire software program (Weiß et al. 2018) to estimate 
 sample ploidy levels from next-generation sequencing (NGS; e.g. Illumina) reads for one or 
 multiple samples, starting from BAM file(s) (extension '.bam'; Li et al. 2009) for the 
 sample(s). It is assumed that the .bam input file(s) were output by an aligner such as 
 bwa (Li and Durbin 2009) and contain information on reads mapped to an appropriate 
 reference (draft reference genome, pseudo-reference genome assembly, etc.).
	The standard way to run this function is to feed it the name of a single input .bam 
 file using the -b flag, which will be read in and used to run several models to determine 
 the ploidy level of the corresponding sample (diploid, triploid, or tetraploid are the only 
 possibilities; where higher ploidy levels are possible/suspected, this approach should not 
 be used). By default, the program selectively sends output to screen, and also saves all 
 pertinent output to files prefixed with the basename of the input .bam file.
	The only dependencies for the nQuireRunner function are nQuire, which can be obtained
 from GitHub (available at: https://github.com/clwgg/nQuire), and Perl. This function has
 been tested with Perl v5.1+ on macOS High Sierra (v10.13+) and with Perl under Centos 5/6/7
 Linux.

 ${bold}Usage examples:${reset}
 Call the program using PIrANHA, as follows:

    piranha -f nQuireRunner -i <inputBAM>      Standard run on single .bam file (one sample)
    piranha -f nQuireRunner -m 1               Multi-bam run on all .bam files in working directory

 ${bold}CITATION${reset}
 Bagley, J.C. 2019. PIrANHA v0.3a2. GitHub repository, Available at:
	<https://github.com/justincbagley/PIrANHA>.

 ${bold}REFERENCES${reset}
 Li, H., Durbin, R. 2009. Fast and accurate short read alignment with Burrows–Wheeler 
	transform. Bioinformatics, 25(14), 1754–1760.
 Li, H., Handsaker, B., Wysoker, A., Fennell, T., Ruan, J., Homer, N., Marth, G., Abecasis, 
	G., Durbin, R., 1000 Genome Project Data Processing Subgroup 2009. The sequence 
	Alignment/Map format and SAMtools. Bioinformatics, 25(16), 2078–2079.
 Weiß, C.L., Pais, M., Cano, L.M., Kamoun, S. Burbano, H.A. 2018. nQuire: a statistical 
	framework for ploidy estimation using next generation sequencing. BMC bioinformatics, 
	19(1), 122.
  
 Created by Justin Bagley on Thu, Oct 17 11:59:08 CDT 2019.
 Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved.
"

if [[ -z "$*" ]]; then
	echo "$USAGE"
	exit
fi

if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
	echo "$USAGE"
	exit
fi

if [[ "$1" == "-H" ]] || [[ "$1" == "--Help" ]]; then
	echo "$VERBOSE_USAGE"
	exit
fi

if [[ "$1" == "-V" ]] || [[ "$1" == "--version" ]]; then
	echo "$(basename $0) $VERSION";
	exit
fi


############ CHECK ARGUMENTS
	# echo "$@"; echo "$#"; echo "$1" 
	# for i in "$@"; do
	# 	echo "$i";
	# done
	# MY_ARGS="$(echo "$@" | perl -pe $'s/\ /\n/')"
	# echo "$MY_ARGS"


############ CLEAN WORKING DIR, CAPTURE ARGUMENTS, SEND TO FILE FOR PARSING
	if [[ -s ./args.tmp ]]; then rm ./args.tmp ; fi ;
	if [[ -s ./args.txt ]]; then rm ./args.txt ; fi ;
	if [[ -s ./*_nQuireRunner.out.txt ]]; then rm ./*_nQuireRunner.out.txt ; fi ;

	ALL_MY_ARGUMENTS="$(echo "$@")"
	echo "$ALL_MY_ARGUMENTS" > ./args.txt
	#perl -p -i -e $'s/\-/\n\-/g' ./args.txt
	#wc -l ./args.txt | perl -pe 's/\.\/args\.txt.*//g' | perl -pe 's/\ //g'


############ MANUALLY PARSE THE OPTIONS FROM ARGS

### SET OPTIONS TO DEFAULT VALUES, EXCEPT WHERE VALUES WERE READ IN FROM USER ARGS
	if [[  "$(grep -h '\-b' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_BAM_FILE=NULL ;
	else 
		MY_ARG="$(grep -h '\-b' ./args.txt | perl -pe 's/\-b//g' | perl -pe 's/\ //g')";
		MY_BAM_FILE="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-m' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_MULTIBAM_SWITCH=0 ;
	else 
		MY_ARG="$(grep -h '\-m' ./args.txt | perl -pe 's/\-m//g' | perl -pe 's/\ //g')";
		MY_MULTIBAM_SWITCH="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-v' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_VERBOSE_OUT_SWITCH=0 ;
	else 
		MY_ARG="$(grep -h '\-v' ./args.txt | perl -pe 's/\-v//g' | perl -pe 's/\ //g')";
		MY_VERBOSE_OUT_SWITCH="$MY_ARG" ;
	fi
#
#	if [[  "$(grep -h '\-k' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
#		MY_KEEP_FASTA_SWITCH=0 ;
#	else 
#		MY_ARG="$(grep -h '\-k' ./args.txt | perl -pe 's/\-k//g' | perl -pe 's/\ //g')";
#		MY_KEEP_FASTA_SWITCH="$MY_ARG" ;
#	fi
#
	if [[  "$(grep -h '\-o' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_OVERWRITE_SWITCH=0 ;
	else 
		MY_ARG="$(grep -h '\-o' ./args.txt | perl -pe 's/\-o//g' | perl -pe 's/\ //g')";
		MY_OVERWRITE_SWITCH="$MY_ARG" ;
	fi
#


# ############ PARSE THE OPTIONS
# while getopts 'b:m:v:k:o:' opt ; do
#   case $opt in
# ## nQuireRunner options:
#     b) MY_BAM_FILE=$OPTARG ;;
#     m) MY_MULTIBAM_SWITCH=$OPTARG ;;
#     v) MY_VERBOSE_OUT_SWITCH=$OPTARG ;;
#     k) MY_KEEP_FASTA_SWITCH=$OPTARG ;;
#     o) MY_OVERWRITE_SWITCH=$OPTARG ;;
# ## Missing and illegal options:
#     :) printf "Missing argument for -%s\n" "$OPTARG" >&2
#        echo "$USAGE" >&2
#        exit 1 ;;
#    \?) printf "Illegal option: -%s\n" "$OPTARG" >&2
#        echo "$USAGE" >&2
#        exit 1 ;;
#   esac
# done
# 
# # Store the remaining part as arguments.
# # args+=("$@")


# ############# ############# #############
# ##       TIME TO RUN THE SCRIPT        ##
# ##                                     ##
# ## You shouldn't need to edit anything ##
# ## beneath this line                   ##
# ##                                     ##
# ############# ############# #############

# Trap bad exits with your cleanup function
trap trapCleanup EXIT INT TERM

# Set IFS to preferred implementation
IFS=$'\n\t'

# Exit on error. Append '||true' when you run the script if you expect an error.
set -o errexit

# Run in debug mode, if set
if ${debug}; then set -x ; fi

# Exit on empty variable
if ${strict}; then set -o nounset ; fi

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error in case mysqldump fails in `mysqldump |gzip`, for example.
set -o pipefail

# Invoke the checkDependenices function to test for Bash packages.  Uncomment if needed.
# checkDependencies

# Run the script
nQuireRunner

# Exit cleanly
safeExit
