#!/bin/sh

##########################################################################################
#  __  o  __   __   __  |__   __                                                         #
# |__) | |  ' (__( |  ) |  ) (__(                                                        # 
# |                                                                                      #
# File: completeSeqs.sh, v1.0                                                            #
# Author: Justin C. Bagley                                                               #
#                                                                                        #
# Created by Justin Bagley on February 24, 2019, email <bagleyj@umsl.edu>                #
# Copyright (c) 2019 Justin C. Bagley. All rights reserved.                              #
#                                                                                        #
# Description:                                                                           #
# SHELL SCRIPT THAT CONVERTS SERIES OF PHYLIP DNA SEQUENCE ALIGNMENTS WITH VARYING       #
# NUMBERS OF TAXA INTO COMPLETE PHYLIP ALIGNMENTS (WITH FULL/SAME NUMBER OF TAXA),       #
# STARTING FROM A TAXON NAMES AND SPACES FILE AND WORKING DIR PATH                       #
##########################################################################################

############ CREATE USAGE & HELP TEXTS
Usage="Usage: $(basename $0) [Help: -h help] [stdin:] <inputNameSpacesFile> <workingDir> 
 ## Help:
  -h   help text (also: -help)

 OVERVIEW
 THIS SCRIPT is designed to run in a working directory containing a series of PHYLIP DNA
 sequence alignments for different genes (e.g. 100s or 1000s of RAD or UCE loci) with 
 varying levels of taxon sampling (completeness), such that out of the total number of tip 
 taxa, some were sequenced for gene A, and possibly the same or a varying number of tip 
 taxa were sequenced for gene B, and so on. Given such a workspace, this script takes as 
 input (1) a 'names and spaces file', <inputNameSpacesFile>, containing only the names of 
 tip taxa, one per line, as well as spaces extending the total number of characters to 
 be the same on each line (e.g. 10 or 12 characters including spaces); and (2) the path
 to the <workingDir> (for current working dir, use '.'; see example usage below). When 
 run, the script converts the PHYLIP alignments into 'complete' alignments, such that 
 all alignments contain the full number of tip taxa, by filling in missing taxa and 
 giving them dummy sequences comprised entirely of missing data (coded as NNNs) in the
 alignment. When calling the program, <inputNameSpacesFile> and <workingDir> are mandatory 
 input, PHYLIP alignment files in <workingDir> are overwritten with 'complete' alignments,
 and by default all script output is written to a file named 'output.txt'.
	This program runs on UNIX-like and Linux systems using commonly distributed utility 
 software, with usage obtained by running the script with the -h flag, and has been 
 tested on macOS High Sierra (v10.13+) and Mojave but will work on many earlier versions or
 Linux (tested on CentOS 6/7). It is assumed that taxon names in the PHYLIP files contain 
 only alphanumeric characters and no spaces, or else there could be issues. 

 USAGE EXAMPLE:
 To run using current directory as <workingDir> with a names and spaces text file named 
 'taxon_name_spaces12.txt' containing each tip taxon name followed by x number of spaces 
 taking the total character count per line out to 12 characters, you would call the program 
 as follows ($ is the command prompt):

 $ ./completeSeqs.sh taxon_name_spaces12.txt .

 CITATION
 Bagley, J.C. 2018. Anoura-UCE-Phylogenomics-Project. GitHub repository, Available at: 
	<https://github.com/justincbagley/Anoura-UCE-Phylogenomics-Project>.

Created by Justin Bagley on February 24, 2019, email <bagleyj@umsl.edu>
Copyright (c) 2019 Justin C. Bagley. All rights reserved.
"

if [[ "$1" == "-h" ]] || [[ "$1" == "-help" ]]; then
	echo "$Usage"
	exit
fi

# Saves all script output to file named 'output.txt'
exec >> ./output.txt 
exec 2>&1

############ Check for mandatory positional parameters
if [ $# -lt 2 ]; then
	echo "WARNING!  | $(date) |          Missing one or more mandatory positional parameters. Quitting... "
	echo "$Usage"
  exit 1
fi
USER_SPEC_NAMSPACES_FILE="$1"
USER_SPEC_PATH="$2"







############ Set <workingDir>
if [[ "$USER_SPEC_PATH" = "$(printf '%q\n' "$(pwd)")" ]] || [[ "$USER_SPEC_PATH" = "." ]]; then
	#MY_CWD=`pwd -P`
	MY_CWD="$(printf '%q\n' "$(pwd)" | sed 's/\\//g')"
	echo "INFO      | $(date) |          Setting working directory to:  "
	echo "$MY_CWD "
elif [[ "$USER_SPEC_PATH" != "$(printf '%q\n' "$(pwd)")" ]]; then
	if [[ "$USER_SPEC_PATH" = ".." ]] || [[ "$USER_SPEC_PATH" = "../" ]] || [[ "$USER_SPEC_PATH" = "..;" ]] || [[ "$USER_SPEC_PATH" = "../;" ]]; then
		cd ..;
		MY_CWD="$(printf '%q\n' "$(pwd)" | sed 's/\\//g')"
	else
		MY_CWD=$USER_SPEC_PATH
		echo "INFO      | $(date) |          Setting working directory to user-specified dir:  "	
		echo "$MY_CWD "
		cd "$MY_CWD"
	fi
else
	echo "WARNING!  | $(date) |          Null working directory path. Quitting... "
	exit 1
fi


######################################## START ###########################################

###### SET UP ENVIRONMENT BY CREATING USEFUL VARIABLES AND FUNCTIONS AND CHECKING MACHINE TYPE.
	CR=$(printf '\r')
	TAB=$(printf '\t')
	calc () {
		bc -l <<< "$@"
}

	###### CHECK MACHINE TYPE:
	unameOut="$(uname -s)"
	case "${unameOut}" in
	    Linux*)     machine=Linux;;
	    Darwin*)    machine=Mac;;
	    CYGWIN*)    machine=Cygwin;;
	    MINGW*)     machine=MinGw;;
	    *)          machine="UNKNOWN:${unameOut}"
	esac


###### CREATE AND RUN COMPLETESEQS FUNCTION 

completeSeqs () {

count=1
(
	for i in ./*.phy; do
		cp "$USER_SPEC_NAMSPACES_FILE" "$i".tmp
		j="$i".tmp
		MY_PHYLIP_NCHAR="$(head -n1 $i | perl -pe 's/^[0-9]*\ +//g; s/\ //g')"
		echo "###----------   $i,  $MY_PHYLIP_NCHAR bp   ----------###"

			while read k; do
				MY_TAXON_NAME="$(echo $k | sed 's/\ //g')"
				MY_N_IND_INSTS="$(grep -n "$MY_TAXON_NAME" "$i" | wc -l | perl -pe 's/\t//g; s/\ //g')"
				MY_1ST_INST_LINE="$(grep -n "$MY_TAXON_NAME" "$i" | head -n1 | sed 's/\:.*//g; s/\ //g' | perl -pe 's/\t//g')"
				#echo "line: $MY_1ST_INST_LINE"

				# $i is expendable & editable (with no mistakes), $j is the key--where the
				# sequences will simply be added to ends of lines with matching taxon 
				# name labels. So, first take the name and check whether it exists in the
				# orig phy file $i. If name exists, copy the sequence and paste it to the end
				# of the line with the same name in the tmp file $j. If it doesn't exist,
				# then only add correct # N's (dummy sequence) to end of line with same
				# name in tmp file $j. When this process is done, $j will be a correct,
				# complete matrix that only needs a PHYLIP header to be added at 1st line
				# in order to create a new complete PHYLIP alignment for locus $i.
				
				if [[ "$MY_N_IND_INSTS" = "1" ]]; then
					# extract/copy corresponding sequence from $i and paste it to end of
					# line with same name ($MY_TAXON_NAME) in tmp file $j:
					MY_SEQUENCE="$(grep -h "$MY_TAXON_NAME" $i | perl -pe 's/^[A-Za-z0-9\-\_\ ]*\ //g' | sed 's/\ //g')"
					if [[ "${machine}" = "Mac" ]]; then
						sed -i '' 's/\(^'"$MY_TAXON_NAME"'[\ ]*\)/\1'"$MY_SEQUENCE"'/g' "$j"
					fi

					if [[ "${machine}" = "Linux" ]]; then
						sed -i 's/\(^'"$MY_TAXON_NAME"'[\ ]*\)/\1'"$MY_SEQUENCE"'/g' "$j"
					fi

					
				elif [[ "$MY_N_IND_INSTS" = "0" ]]; then
					# only add correct # N's (dummy sequence) to end of line with same
					# name in tmp file $j:
					if [[ "${machine}" = "Mac" ]]; then
						sed -i '' 's/\(^'"$MY_TAXON_NAME"'[\ ]*\)/\1'"$(printf 'N%.0s' {$(seq 1 $MY_PHYLIP_NCHAR)})"'/g' "$j"
					fi

					if [[ "${machine}" = "Linux" ]]; then
						sed -i 's/\(^'"$MY_TAXON_NAME"'[\ ]*\)/\1'"$(printf 'N%.0s' {$(seq 1 $MY_PHYLIP_NCHAR)})"'/g' "$j"
					fi

				fi				
				
			done < "$USER_SPEC_NAMSPACES_FILE"

	echo "$((count++))" > count.tmp
	
	# Overwrite original phy file $i with new edited tmp file $j
	#cp -f "$j" "$i"
	# SKIP THIS FOR NOW! Just use $j during cat below...
	
	# Add header with corrected ntax and nchar information:
	MY_PHY_NTAX="$(awk 'END {print NR,"lines"}' $j | sed 's/\ .*//g')";

	echo "$MY_PHY_NTAX  $MY_PHYLIP_NCHAR" > ./header.tmp

	# Overwrite original phy file with new phy file:
	cat ./header.tmp "$j" > "$i"
		
	done
)

}

## DON'T FORGET TO RUN THE FUNCTION!
completeSeqs


############ CLEAN UP WORKING DIR BY DELETING TEMPORARY FILES.
	
	rm ./*.tmp


#
#
#
######################################### END ############################################

exit 0

