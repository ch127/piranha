#!/bin/sh

##########################################################################################
#  __  o  __   __   __  |__   __                                                         #
# |__) | |  ' (__( |  ) |  ) (__(                                                        # 
# |                                                                                      #
#                                                                                        #
# File: trimSeqs.sh                                                                      #
  VERSION="v1.0.0"                                                                       #
# Author: Justin C. Bagley                                                               #
# Date: Created by Justin Bagley on Mon, Jul 27 16:37:22 CDT 2020.                       #
# Last update: July 31, 2020                                                             #
# Copyright (c) 2020 Justin C. Bagley. All rights reserved.                              #
# Please report bugs to <jbagley@jsu.edu>.                                              #
#                                                                                        #
# Description:                                                                           #
# THIS SCRIPT AUTOMATES TRIMMING AND FILTERING DNA SEQUENCES IN SEQUENTIAL PHYLIP        #
# ALIGNMENT FORMAT USING trimAl WITH GENERALIZED IDENTITY THRESHOLD AND GAP TRIMMING OR  #
# CUSTOM USER-SPECIFIED OPTIONS                                                          #
#                                                                                        #
##########################################################################################

# Provide a variable with the location of this script.
SCRIPT_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Source Scripting Utilities
# -----------------------------------
# These shared utilities provide many functions which are needed to provide
# the functionality in this boilerplate. This script will fail if they can
# not be found.
# -----------------------------------

UTILS_LOCATION="${SCRIPT_PATH}/../lib/utils.sh" # Update this path to find the utilities.

if [[ -f "${UTILS_LOCATION}" ]]; then
  source "${UTILS_LOCATION}"
else
  echo "Please find the file util.sh and add a reference to it in this script. Exiting..."
  exit 1
fi

# Source shared functions and variables
# -----------------------------------

FUNCS_LOCATION="${SCRIPT_PATH}/../lib/sharedFunctions.sh" # Update this path to find the shared functions.
VARS_LOCATION="${SCRIPT_PATH}/../lib/sharedVariables.sh" # Update this path to find the shared variables.

if [[ -f "${FUNCS_LOCATION}" ]] && [[ -f "${VARS_LOCATION}" ]]; then
  source "${FUNCS_LOCATION}" ;
  source "${VARS_LOCATION}" ;
else
  echo "Please find the files sharedFunctions.sh and sharedVariables.sh and add references to them in this script. Exiting... "
  exit 1
fi

# trapCleanup Function
# -----------------------------------
# Any actions that should be taken if the script is prematurely
# exited.  Always call this function at the top of your script.
# -----------------------------------
trapCleanup () {
  echo ""
  # Delete temp files, if any
  if is_dir "${tmpDir}"; then
    rm -r "${tmpDir}"
  fi
  die "Exit trapped. In function: '${FUNCNAME[*]}'"
}

# safeExit
# -----------------------------------
# Non destructive exit for when script exits naturally.
# Usage: Add this function at the end of every script.
# -----------------------------------
safeExit () {
  # Delete temp files, if any
  if is_dir "${tmpDir}"; then
    rm -r "${tmpDir}"
  fi
  if [[ -s ./args.txt ]]; then rm ./args.txt ; fi
  trap - INT TERM EXIT
  exit
}

# Set Flags
# -----------------------------------
# Flags which can be overridden by user input.
# Default values are below
# -----------------------------------
quiet=false
printLog=false
verbose=false
force=false
strict=false
debug=false
args=()

# Set Temp Directory
# -----------------------------------
# Create temp directory with three random numbers and the process ID
# in the name.  This directory is removed automatically at exit.
# -----------------------------------
tmpDir="/tmp/${SCRIPT_NAME}.$RANDOM.$RANDOM.$RANDOM.$$"
(umask 077 && mkdir "${tmpDir}") || {
  die "Could not create temporary directory! Exiting."
}

# Logging
# -----------------------------------
# Log is only used when the '-l' flag is set.
#
# To never save a logfile change variable to '/dev/null'
# Save to Desktop use: $HOME/Desktop/${SCRIPT_BASENAME}.log
# Save to standard user log location use: $HOME/Library/Logs/${SCRIPT_BASENAME}.log
# -----------------------------------
logFile="$HOME/Library/Logs/${SCRIPT_BASENAME}.log"

# Check for Dependencies
# -----------------------------------
# Arrays containing package dependencies needed to execute this script.
# The script will fail if dependencies are not installed.  For Mac users,
# most dependencies can be installed automatically using the package
# manager 'Homebrew'.  Mac applications will be installed using
# Homebrew Casks. Ruby and gems via RVM.
# -----------------------------------
export homebrewDependencies=()
export caskDependencies=()
export gemDependencies=()



####################################### FUNCTION #########################################
## First, make sequential_FASTA2PHYLIP function used in trimSeqs when output format is set 
## to "phylip" using -o, --output flag:

sequential_FASTA2PHYLIP () {

#	calc () { 
#		bc -l <<< "$@"  
#}
	#MY_FASTA_FILES="$(find . -type f \( -iname \*.fasta -o -iname \*.fas  -o -iname \*.fa -o -iname \*.FASTA -o -iname \*.FAS -o -iname \*.FA \))"
	(
		for MY_FASTA in ./*_sequential.fas ; do
			## If present, remove empty lines / newlines from input FASTA file, $MY_FASTA.
				if [[ "$(grep -n '^[\s]*$' $MY_FASTA | wc -l | sed 's/\ //g' | perl -pe 's/\t//g')" -gt "0" ]]; then 
						sed -i.bak '/^[[:space:]]*$/d' "$MY_FASTA" ;
						rm ./*.bak ;
				fi
			
			## If present, remove lines that have been commented out from input FASTA file, $MY_FASTA. 
			## Unlike sequence lines, these lines will all contain '#' characters.
				if [[ "$(grep -n '\#' $MY_FASTA | wc -l | sed 's/\ //g' | perl -pe 's/\t//g')" -gt "0" ]]; then 
						sed -i.bak '/\#/d' "$MY_FASTA" ;
						rm ./*.bak ;
				fi
			
			#####  SEQUENTIAL, UNWRAPPED FASTA2PHYLIP CONVERSION CODE  #####
			
			## The FASTA file has DNA sequences in sequential, unwrapped format already; no need to 
			## convert it, so use file as is.
			
			## Count number of taxa/tips present in FASTA file:
			MY_NTAXA="$(grep -n '^>' $MY_FASTA | wc -l | perl -pe 's/^\ +//g')";
			
			## This is the base name of the original FASTA file, so you have it. This will work regardless 
			## of whether the FASTA filename extension is written in lowercase or in all caps, as 
			## abbreviated (".fas", ".FAS") or in full (".fasta", ".FASTA").
			MY_FASTA_BASENAME="$(echo $MY_FASTA | sed 's/\.\///g; s/\.[A-Za-z]\{3,\}$//g')";
		
			## Count corrected number of characters in DNA alignment
			MY_INITIAL_NCHAR="$(head -n2 "$MY_FASTA" | tail -n+2 | wc -c | sed 's/\ //g' | perl -pe 's/\t//g')";
			MY_CORRECTED_NCHAR="$(calc $MY_INITIAL_NCHAR - 1)";
		
			## Convert sequential, unwrapped FASTA file to PHYLIP format:
			# Make tmp PHYLIP header.
			echo "$MY_NTAXA  $MY_CORRECTED_NCHAR" > ./header.tmp ;
		
			# 1 line per sequence, no '>' delimiter.
			perl -p -i -e 's/\>(.*)\n/$1\ /g' "$MY_FASTA" ;
		
			sed 's/^\([A-Z\_a-z0-9\-]*\)[\ ]*.*/\1/g' "$MY_FASTA" > ./taxonLabels.tmp ;
			MY_TAX_LABELS="$(sed 's/^\([A-Z\_a-z0-9\-]*\)[\ ]*.*/\1/g' $MY_FASTA | sed 's/$/\ /g' | perl -pe 's/\n//g')";
			sed 's/^[A-Z\_a-z0-9\-]*[\ ]*\(.*\)/\1/g' "$MY_FASTA" > ./fastaSeqs.tmp ;
			#MY_SEQUENCES="$(sed 's/^[A-Z\_a-z0-9\-]*[\ ]*\(.*\)/\1/g' $MY_FASTA  | sed 's/$/\ /g' | perl -pe 's/\n//g')";
			
			perl -p -i -e 's/(..)$/$1\ \ x/g' ./taxonLabels.tmp ;
			#column -t ./taxonLabels.tmp > tmp; mv tmp ./taxonLabels.tmp ;
			perl -p -i -e 's/x$//g' ./taxonLabels.tmp; mv ./taxonLabels.tmp ./taxon_names_spaces.tmp ;
					
			paste ./taxon_names_spaces.tmp ./fastaSeqs.tmp > ./new_fasta_body.tmp ;
			cat ./header.tmp ./new_fasta_body.tmp > "$MY_FASTA_BASENAME".phy  ;
		
			## Remove any tab characters (these are artifacts of operation above).
			perl -p -i -e 's/\t//g' ./"$MY_FASTA_BASENAME".phy ;
	
			## Remove orig FASTA file and delete temporary files.
			rm "$MY_FASTA" ;
			if [[ "$(ls -1 ./*.tmp 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				rm ./*.tmp ; 
			fi
		done
	)
}



####################################### FUNCTION #########################################
## Also make sequential_PHYLIP2NEXUS function for creating trimmed NEXUS format alignment 
## output files:

sequential_PHYLIP2NEXUS () {

INPUT_PHYLIP_FILE="$1"

###
	MY_PHYLIP_LENGTH="$(cat $INPUT_PHYLIP_FILE | wc -l | sed 's/(\ )*//g')";
	MY_BODY_LENGTH="$(calc $MY_PHYLIP_LENGTH - 1)";
	## This "MY_BODY_LENGTH" is number of lines comprised by sequence and eof lines; was going to call it "MY_SEQUENCE_AND_EOF_LINES" but thought that name was too long.
	tail -n$MY_BODY_LENGTH $INPUT_PHYLIP_FILE > sequences.tmp;
	MY_NTAX="$(head -n1 $INPUT_PHYLIP_FILE | sed 's/\ [0-9]*//g'| sed 's/[\]*//g')";
	MY_NCHAR="$(head -n1 $INPUT_PHYLIP_FILE | sed 's/^[0-9]*\ //g'| sed 's/[\]*//g' | sed 's/\ //g')";

###### Make NEXUS format file:

echo "#NEXUS

BEGIN DATA;
	DIMENSIONS NTAX="${MY_NTAX}" NCHAR="${MY_NCHAR}";
	FORMAT DATATYPE=DNA GAP=- MISSING=N;
	MATRIX" > NEXUS_top.tmp

echo ";
END;
" > NEXUS_bottom.tmp ;

	MY_PHYLIP_BASENAME="$(basename "$INPUT_PHYLIP_FILE" '.phy')" ;

	cat ./NEXUS_top.tmp ./sequences.tmp ./NEXUS_bottom.tmp > "$MY_PHYLIP_BASENAME".nex ;

	perl -p -i -e $'s/^'"$MY_NTAX"'\ +[0-9]*.*\n//g' "$MY_PHYLIP_BASENAME".nex ; 
	perl -p -i -e $'s/^'"$MY_NTAX"'\t[0-9]*.*\n//g' "$MY_PHYLIP_BASENAME".nex ; 


#### ADDITIONAL EDITS CLEANING FINAL NEXUS FILE:

	## Remove second NEXUS header if accidentally added to NEXUS partitions file by user
	## using the -NEX option (accommodate '#nexus', '#NEXUS', and '#Nexus'):
	MY_NEXUS_HEADER_COUNT="$(grep -h '\#NEXUS\|\#Nexus\|\#nexus' "$MY_PHYLIP_BASENAME".nex  | wc -l | sed 's/\ //g')";

	if [[ "$MY_NEXUS_HEADER_COUNT" -gt "1" ]]; then
		MY_UNWANTED_NEXUS_LINES="$(grep -n '\#NEXUS\|\#Nexus\|\#nexus' "$MY_PHYLIP_BASENAME".nex  | sed '1d' | sed 's/\:.*//g')";
		(
			for i in $MY_UNWANTED_NEXUS_LINES; do
				if [[ "${machine}" = "Mac" ]]; then
					sed -i.bak ''"$i"'d' "$MY_PHYLIP_BASENAME".nex ;
					rm ./*.bak ;
				fi
				if [[ "${machine}" = "Linux" ]]; then
					sed -i ''"$i"'d' "$MY_PHYLIP_BASENAME".nex ;
				fi
			done
		)
	fi

	## Remove PHYLIP header if present on line 7 of the new NEXUS file. This sometimes happens
	## when the total number of sequences is odd (because of EOF line handling?). Just check 
	## for it and remove the line if present, as follows:
	if [[ "$(sed -n '7p' "$MY_PHYLIP_BASENAME".nex | wc -c | sed 's/\ //g')" -lt "20" ]]; then 
		if [[ "${machine}" = "Mac" ]]; then
			sed -i.bak '7d' "$MY_PHYLIP_BASENAME".nex ;
			rm ./*.bak ;
		fi
		if [[ "${machine}" = "Linux" ]]; then
			sed -i '7d' ./"$MY_PHYLIP_BASENAME".nex ;
		fi
	fi

	## Replace \? missing characters with Ns, if present:
	if [[ "$( grep -h '\?' "$MY_PHYLIP_BASENAME".nex | wc -l )" -gt "0" ]]; then 
		if [[ "${machine}" = "Mac" ]]; then
			sed -i.bak 's/\?/N/g' "$MY_PHYLIP_BASENAME".nex ;
			rm ./*.bak ;
		fi
		if [[ "${machine}" = "Linux" ]]; then
			sed -i 's/\?/N/g' "$MY_PHYLIP_BASENAME".nex ;
		fi
	fi
###

	## Clean up workspace by removing temporary or unnecessary files created above:
	if [[ -s "$MY_PHYLIP_BASENAME".phy ]]; then rm "$MY_PHYLIP_BASENAME".phy ; fi ;
	
	if [[ "$(ls -1 ./*.tmp 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
		rm ./*.tmp ; 	## Remove tmp files if present.
	fi

}



trimSeqs () {

######################################## START ###########################################
##########################################################################################

echo "INFO      | $(date) |----------------------------------------------------------------"
echo "INFO      | $(date) | trimSeqs, v1.0.0 July 2020                                     "
echo "INFO      | $(date) | Copyright (c) 2020 Justin C. Bagley. All rights reserved.      "
echo "INFO      | $(date) |----------------------------------------------------------------"

######################################## START ###########################################
echo "INFO      | $(date) | Starting trimSeqs analysis... "
echo "INFO      | $(date) | ----------------------------------- "
echo "INFO      | $(date) | Step #1: Set up workspace, check machine type, and determine output file settings. "
echo "INFO      | $(date) | ----------------------------------- "

################################# 1. SETUP

	###### A. START DEBUG MODE IF SET:
	if [[ "$MY_DEBUG_MODE_SWITCH" != "0" ]]; then set -xv; fi

	###### B. HANDLE WORKING DIRECTORY, ECHO PWD, SHORTEN PWD IF TOO LONG, AND ECHO OPTIONS SETTINGS:
	## Starting directory:
	echoShortPWD

	## Echo function options settings:
	echo "INFO      | $(date) | Output format setting:                     $MY_OUTPUT_FORMAT (def: fasta) "
	echo "INFO      | $(date) | Avg. seq. identity threshold (st) setting: $MY_MAX_AVG_IDENT_THRESH (def: 0.98) "
	echo "INFO      | $(date) | Log file:                                  $MY_LOGFILE_SWITCH (def: trimSeqs_log.txt) "
	echo "INFO      | $(date) | Verbose mode:                              $MY_VERBOSE_OUT_SWITCH (1, on; 0, off) "
	echo "INFO      | $(date) | Debug mode:                                $MY_DEBUG_MODE_SWITCH (0, off; 1, on) "

	####### C. CHECK MACHINE TYPE:
	checkMachineType


echo "INFO      | $(date) | ----------------------------------- "
echo "INFO      | $(date) | Step #2: Run main program, trim sequences in one or multiple alignments using trimAl... "
echo "INFO      | $(date) | ----------------------------------- "

################################# 2. MAIN SCRIPT

############ CASE #1: SINGLE INPUT SEQUENTIAL PHYLIP FILE
##
if [[ "$INPUT_PHYLIP_FILE" != "NULL" ]] && [[ -s "$INPUT_PHYLIP_FILE" ]] && [[ "$MULTIPLE_PHYLIP_SWITCH" != "1" ]]; then
	if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
		echo "INFO      | $(date) | Trimming single input PHYLIP alignment in trimAl. "
	fi
	j="$INPUT_PHYLIP_FILE"; 
	INPUT_PHYLIP_FILE="$(echo "$j" | sed 's/\.\///g')";
	MY_BASENAME="$(basename "$INPUT_PHYLIP_FILE" '.phy')" ;
#
	## RUN trimAl ON PHYLIP FILE:
	touch "$MY_BASENAME"_trimal_log.txt ;
	if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
		echo "INFO      | $(date) | ----------------- Trimming file: ${MY_BASENAME}.phy " | tee -a "$MY_BASENAME"_trimal_log.txt ;
	fi
	if [[ "$MY_NO_GAPS_SWITCH" = "0" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" = "1" ]]; then
		## Run while removing all sites composed entirely of gaps:
		trimal -in "$MY_BASENAME".phy -out "$MY_BASENAME"_trimal.fas -fasta -noallgaps -sident >>"$MY_BASENAME"_trimal_log.txt 2>&1 ;
	elif [[ "$MY_NO_GAPS_SWITCH" = "0" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" = "0" ]]; then
		## Run with default/user-specified gap handling parameters:
		trimal -in "$MY_BASENAME".phy -out "$MY_BASENAME"_trimal.fas -fasta -cons "$MY_MIN_CONS_THRESH" -gt "$MY_GAP_THRESH" -sident >>"$MY_BASENAME"_trimal_log.txt 2>&1 ;
	elif [[ "$MY_NO_GAPS_SWITCH" = "1" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" = "0" ]]; then
		## Run with more stringent settings, removing all sites with any gaps:
		trimal -in "$MY_BASENAME".phy -out "$MY_BASENAME"_trimal.fas -fasta -nogaps -sident >>"$MY_BASENAME"_trimal_log.txt 2>&1 ;
	fi
#
	## EVALUATE AVERAGE IDENTITY AGAINST DESIRED THRESHOLD:
	MY_AVG_IDENT="$(grep '## AverageIdentity[[:space:]]*' "$MY_BASENAME"_trimal_log.txt | perl -pe $'s/\#\#.*\t//g' | sed 's/\ //g')";
	if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
		echo "INFO      | $(date) | Average Identity: ${MY_AVG_IDENT}" | tee -a "$MY_BASENAME"_trimal_log.txt ; 
	fi
	# BETTER SOLUTION (mine):
	if [[ $(echo "${MY_AVG_IDENT} > ${MY_MAX_AVG_IDENT_THRESH}" | bc -l) = "0" ]]; then 
		echo "INFO      | $(date) | This alignment PASSED the minimum Average Identity threshold (${MY_MAX_AVG_IDENT_THRESH}). You're good!" | tee -a "$MY_BASENAME"_trimal_log.txt ; 
	else
		echo "WARNING   | $(date) | This alignment FAILED to meet the minimum Average Identity threshold (${MY_MAX_AVG_IDENT_THRESH}). "  | tee -a "$MY_BASENAME"_trimal_log.txt ; 
		echo "INFO      | $(date) | Moving to discarded_alignments/ subfolder generated in current directory. " | tee -a "$MY_BASENAME"_trimal_log.txt ; 
		if [[ ! -s ./discarded_alignments/ ]]; then mkdir ./discarded_alignments/ ; fi
		mv "$MY_BASENAME".phy ./discarded_alignments/ ;
	fi
#
	## OPTIONALLY DELETE THE ORIGINAL PHYLIP FILE:
	if [[ "$KEEP_ORIG_PHYLIP_SWITCH" = "0" ]]; then
		if [[ -s "$MY_BASENAME".phy ]]; then rm "$MY_BASENAME".phy ; fi ; 
	fi
#


if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
	echo "INFO      | $(date) | ----------------- Additional file-processing steps: " | tee -a "$MY_BASENAME"_trimal_log.txt ;
fi

	if [[ ! -s ./trimal_output/ ]]; then mkdir ./trimal_output/ ; fi
	mv ./*_trimal_log.txt ./trimal_output/ ;
	if [[ "$MY_OUTPUT_FORMAT" = "fasta" ]] || [[ "$MY_OUTPUT_FORMAT" = "fas" ]]; then
		mv ./*_trimal.fas ./trimal_output/ ;
		cd ./trimal_output/;
			## Convert interleaved FASTA to sequential FASTA:
			if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
				echo "INFO      | $(date) | Intermediate step: Converting interleaved, trimmed FASTA file to sequential FASTA format... " 
			fi
			(
				for i in ./*_trimal.fas; do
					MY_BASENAME="$(basename "$i" '.fas')";
					if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
						echo "INFO      | $(date) | FASTA basename: ${MY_BASENAME} "
					fi
					awk '{if(NR==1) {print $0} else {if($0 ~ /^>/) {print "\n"$0} else {printf $0}}}' "$i" > "$MY_BASENAME"_sequential.fas  ;
				done
			)

			## Remove any original trimal FASTA files in trimal_output/ subfolder:
			if [[ "$(ls -1 ./*_trimal.fas 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				rm ./*_trimal.fas ; 
			fi
		cd ..;
	fi
#
	if [[ "$MY_OUTPUT_FORMAT" = "phylip" ]] || [[ "$MY_OUTPUT_FORMAT" = "phy" ]]; then
		mv ./*_trimal.fas ./trimal_output/ ;
		cd ./trimal_output/;
			## Convert interleaved FASTA to sequential FASTA:
			if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
				echo "INFO      | $(date) | Intermediate step: Converting interleaved, trimmed FASTA file to sequential FASTA format... " 
			fi
			(
				for i in ./*_trimal.fas; do
					MY_BASENAME="$(basename "$i" '.fas')";
					awk '{if(NR==1) {print $0} else {if($0 ~ /^>/) {print "\n"$0} else {printf $0}}}' "$i" > "$MY_BASENAME"_sequential.fas  ;
				done
			)
			
			## Convert sequential FASTA to PHYLIP:
			if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
				echo "INFO      | $(date) | Intermediate step: Converting sequential FASTA file to PHYLIP format using sequential_FASTA2PHYLIP function... " 
			fi
			sequential_FASTA2PHYLIP
			
			## Remove any remaining FASTA files in trimal_output/ subfolder:
			if [[ "$(ls -1 ./*.fas 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
					echo "INFO      | $(date) | Removing intermediate FASTA file from trimal_output/ subfolder... " 
				fi
				rm ./*.fas ; 
			fi
		cd ..;
	fi
#
	if [[ "$MY_OUTPUT_FORMAT" = "nexus" ]] || [[ "$MY_OUTPUT_FORMAT" = "nex" ]]; then
		mv ./*_trimal.fas ./trimal_output/ ;
		cd ./trimal_output/;
			## Convert interleaved FASTA to sequential FASTA:
			if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
				echo "INFO      | $(date) | Intermediate step: Converting interleaved, trimmed FASTA file to sequential FASTA format... " 
			fi
			(
				for i in ./*_trimal.fas; do
					MY_BASENAME="$(basename "$i" '.fas')";
					awk '{if(NR==1) {print $0} else {if($0 ~ /^>/) {print "\n"$0} else {printf $0}}}' "$i" > "$MY_BASENAME"_sequential.fas  ;
				done
			)
			
			## Convert sequential FASTA to PHYLIP:
			if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
				echo "INFO      | $(date) | Intermediate step: Converting sequential FASTA file to PHYLIP format using sequential_FASTA2PHYLIP function... " 
			fi
			sequential_FASTA2PHYLIP  ;
			
			## Remove any remaining FASTA files in trimal_output/ subfolder:
			if [[ "$(ls -1 ./*.fas 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
					echo "INFO      | $(date) | Removing intermediate FASTA file from trimal_output/ subfolder... " 
				fi
				rm ./*.fas ; 
			fi
			
			## Convert trimmed sequential PHYLIP to NEXUS:
			if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
				echo "INFO      | $(date) | Intermediate step: Converting sequential PHYLIP file to NEXUS format using sequential_PHYLIP2NEXUS function... " 
			fi
			(
				for i in ./*.phy; do
					sequential_PHYLIP2NEXUS "$i"  ;
				done
			)
			
		cd ..;
	fi
#
elif [[ "$INPUT_PHYLIP_FILE" != "NULL" ]] && [[ ! -s "$INPUT_PHYLIP_FILE" ]]; then
	echo "WARNING   | $(date) | ERROR: Found no PHYLIP file named $INPUT_PHYLIP_FILE in current working directory. Quitting... " 
	exit ;
fi
##

############ CASE #2: MULTIPLE SEQUENTIAL PHYLIP FILES IN CURRENT DIRECTORY
##
if [[ "$INPUT_PHYLIP_FILE" = "NULL" ]] && [[ "$MULTIPLE_PHYLIP_SWITCH" = "1" ]]; then
	MY_PHYLIP_COUNT="$(ls -1 *.phy 2>/dev/null | wc -l | perl -pe $'s/\ //g; s/\t//g')";
	if [[ "$MY_PHYLIP_COUNT" != "0" ]]; then
		if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
			echo "INFO      | $(date) | Looping through input PHYLIP alignments, and trimming sequences... " 
		fi
		count=1
		(
			for i in ./*.phy; do
				MY_BASENAME="$(basename "$i" '.phy')" ;
				touch "$MY_BASENAME"_trimal_log.txt ;
				
				if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
					echo "INFO      | $(date) | ----------------- Trimming file (${count} / ${MY_PHYLIP_COUNT}): ${MY_BASENAME}.phy " | tee -a "$MY_BASENAME"_trimal_log.txt ;
				fi
				## RUN trimAl ON PHYLIP FILE:
				if [[ "$MY_NO_GAPS_SWITCH" = "0" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" = "1" ]]; then
					## Run while removing all sites composed entirely of gaps:
					trimal -in "$MY_BASENAME".phy -out "$MY_BASENAME"_trimal.fas -fasta -noallgaps -sident >>"$MY_BASENAME"_trimal_log.txt 2>&1 ;
				elif [[ "$MY_NO_GAPS_SWITCH" = "0" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" = "0" ]]; then
					## Run with default/user-specified gap handling parameters:
					trimal -in "$MY_BASENAME".phy -out "$MY_BASENAME"_trimal.fas -fasta -cons "$MY_MIN_CONS_THRESH" -gt "$MY_GAP_THRESH" -sident >>"$MY_BASENAME"_trimal_log.txt 2>&1 ;
				elif [[ "$MY_NO_GAPS_SWITCH" = "1" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" = "0" ]]; then
					## Run with more stringent settings, removing all sites with any gaps:
					trimal -in "$MY_BASENAME".phy -out "$MY_BASENAME"_trimal.fas -fasta -nogaps -sident >>"$MY_BASENAME"_trimal_log.txt 2>&1 ;
				fi
#
				## EVALUATE AVERAGE IDENTITY AGAINST DESIRED THRESHOLD:
				MY_AVG_IDENT="$(grep '## AverageIdentity[[:space:]]*' "$MY_BASENAME"_trimal_log.txt | perl -pe $'s/\#\#.*\t//g' | sed 's/\ //g')";
				if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
					echo "INFO      | $(date) | Average Identity: ${MY_AVG_IDENT}" | tee -a "$MY_BASENAME"_trimal_log.txt ; 
				fi
				# BETTER SOLUTION (mine):
				if [[ $(echo "${MY_AVG_IDENT} > ${MY_MAX_AVG_IDENT_THRESH}" | bc -l) = "0" ]]; then 
					echo "INFO      | $(date) | This alignment PASSED the minimum Average Identity threshold (${MY_MAX_AVG_IDENT_THRESH}). You're good!" | tee -a "$MY_BASENAME"_trimal_log.txt ;  
				else
					echo "WARNING   | $(date) | This alignment FAILED to meet the minimum Average Identity threshold (${MY_MAX_AVG_IDENT_THRESH}). " | tee -a "$MY_BASENAME"_trimal_log.txt ;  
					echo "INFO      | $(date) | Moving to discarded_alignments/ subfolder generated in current directory. " | tee -a "$MY_BASENAME"_trimal_log.txt ;  
					if [[ ! -s ./discarded_alignments/ ]]; then mkdir ./discarded_alignments/ ; fi
					mv "$MY_BASENAME".phy ./discarded_alignments/ ;
				fi

				## OPTIONALLY DELETE THE ORIGINAL PHYLIP FILE:
				if [[ "$KEEP_ORIG_PHYLIP_SWITCH" = "0" ]]; then
					if [[ -s "$MY_BASENAME".phy ]]; then rm "$MY_BASENAME".phy ; fi ; 
				fi
#
				echo "INFO      | $(date) | Complete. " 
				echo "$((count++)) "  >/dev/null 2>&1 ;
			done
		)
	else
		echo "WARNING   | $(date) | ERROR: Found no PHYLIP files in current working directory. Quitting... " 
		exit ;
	fi
#

if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
	echo "INFO      | $(date) | ----------------- Additional file-processing steps: " | tee -a "$MY_BASENAME"_trimal_log.txt ;
fi

	if [[ ! -s ./trimal_output/ ]]; then mkdir ./trimal_output/ ; fi
	mv ./*_trimal_log.txt ./trimal_output/ ;
	if [[ "$MY_OUTPUT_FORMAT" = "fasta" ]] || [[ "$MY_OUTPUT_FORMAT" = "fas" ]]; then
		mv ./*_trimal.fas ./trimal_output/ ;
		cd ./trimal_output/;
			## Convert interleaved FASTA to sequential FASTA:
			echo "INFO      | $(date) | Intermediate step: Converting interleaved, trimmed FASTA files to sequential FASTA format... " 
			(
				for i in ./*_trimal.fas; do
					MY_BASENAME="$(basename "$i" '.fas')";
					awk '{if(NR==1) {print $0} else {if($0 ~ /^>/) {print "\n"$0} else {printf $0}}}' "$i" > "$MY_BASENAME"_sequential.fas  ;
				done
			)

			## Remove any original trimal FASTA files in trimal_output/ subfolder:
			if [[ "$(ls -1 ./*_trimal.fas 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				rm ./*_trimal.fas ; 
			fi
		cd ..;
	fi
#
	if [[ "$MY_OUTPUT_FORMAT" = "phylip" ]] || [[ "$MY_OUTPUT_FORMAT" = "phy" ]]; then
		mv ./*_trimal.fas ./trimal_output/ ;
		cd ./trimal_output/;
			## Convert interleaved FASTA to sequential FASTA:
			echo "INFO      | $(date) | Intermediate step: Converting interleaved, trimmed FASTA files to sequential FASTA format... " 
			(
				for i in ./*_trimal.fas; do
					MY_BASENAME="$(basename "$i" '.fas')";
					awk '{if(NR==1) {print $0} else {if($0 ~ /^>/) {print "\n"$0} else {printf $0}}}' "$i" > "$MY_BASENAME"_sequential.fas  ;
				done
			)
			
			## Convert sequential FASTA to PHYLIP:
			echo "INFO      | $(date) | Intermediate step: Converting sequential FASTA files to PHYLIP format using sequential_FASTA2PHYLIP function... " 
			sequential_FASTA2PHYLIP  ;
			
			## Remove any remaining FASTA files in trimal_output/ subfolder:
			if [[ "$(ls -1 ./*.fas 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				echo "INFO      | $(date) | Removing intermediate FASTA files from trimal_output/ subfolder... " 
				rm ./*.fas ; 
			fi
			
		cd ..;
	fi
#
	if [[ "$MY_OUTPUT_FORMAT" = "nexus" ]] || [[ "$MY_OUTPUT_FORMAT" = "nex" ]]; then
		mv ./*_trimal.fas ./trimal_output/ ;
		cd ./trimal_output/;
			## Convert interleaved FASTA to sequential FASTA:
			echo "INFO      | $(date) | Intermediate step: Converting interleaved, trimmed FASTA files to sequential FASTA format... " 
			(
				for i in ./*_trimal.fas; do
					MY_BASENAME="$(basename "$i" '.fas')";
					awk '{if(NR==1) {print $0} else {if($0 ~ /^>/) {print "\n"$0} else {printf $0}}}' "$i" > "$MY_BASENAME"_sequential.fas  ;
				done
			)
			
			## Convert sequential FASTA to PHYLIP:
			echo "INFO      | $(date) | Intermediate step: Converting sequential FASTA files to PHYLIP format using sequential_FASTA2PHYLIP function... " 
			sequential_FASTA2PHYLIP  ;
			
			## Remove any remaining FASTA files in trimal_output/ subfolder:
			if [[ "$(ls -1 ./*.fas 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
				echo "INFO      | $(date) | Removing intermediate FASTA files from trimal_output/ subfolder... " 
				rm ./*.fas ; 
			fi
			
			## Convert trimmed sequential PHYLIP to NEXUS:
			echo "INFO      | $(date) | Intermediate step: Converting sequential PHYLIP files to NEXUS format using sequential_PHYLIP2NEXUS function... " 
			(
				for i in ./*.phy; do
					sequential_PHYLIP2NEXUS "$i"  ;
				done
			)
			
		cd ..;
	fi
fi
##

	echo "INFO      | $(date) | Complete. " 


echo "INFO      | $(date) | ----------------------------------- "
echo "INFO      | $(date) | Step #3: Clean up workspace by removing temporary files generated during run. "
echo "INFO      | $(date) | ----------------------------------- "

################################# 3. CLEAN UP WORKSPACE 

###### Remove temporary or unnecessary files created above:
echo "INFO      | $(date) | Removing temporary files... "
	
	if [[ "$(ls -1 ./*.tmp 2>/dev/null | wc -l | sed 's/\ //g')" != "0"  ]]; then 
		rm ./*.tmp ; 	## Remove tmp files if present.
	fi

	if [[ -s ./args.txt ]]; then rm ./args.txt ; fi 	## Remove arguments file generated when parsing the options.

	if [[ -s ./trimal_output/_trimal_log.txt  ]] || [[ -e ./trimal_output/_trimal_log.txt  ]]; then rm ./trimal_output/_trimal_log.txt ; fi 	## Delete empty log file sometimes produced in output folder.

echo "INFO      | Done."
echo "----------------------------------------------------------------------------------------------------------"
if [[ -s ./discarded_alignments/ ]]; then 
	echo "output file locations: ./trimal_output/ "
	echo "                       ./discarded_alignments/ "
else
	echo "output file location: ./trimal_output/ "
fi

echo ""

if [[ "$MY_DEBUG_MODE_SWITCH" != "0" ]]; then set +xv; fi
###### END DEBUG MODE

##########################################################################################
######################################### END ############################################

}




# ############ SCRIPT OPTIONS
# ## OPTION DEFAULTS ##
# INPUT_PHYLIP_FILE                          # default: NULL; if specified as name of input PHYLIP file, then this causes the program to run only on the single PHYLIP file that is specified.
# MULTIPLE_PHYLIP_SWITCH                     # default: 0, run on single input PHYLIP (must be passed with -i / --input flag); 1, run on multiple PHYLP files in current working directory.
# MY_OUTPUT_FORMAT                           # default: fasta; also: phylip, nexus.
# MY_MIN_CONS_THRESH                         # default: 60, takes integer percentage of original sites to conserve.
# MY_GAP_THRESH                              # default: 0.2, takes float value; 0.2 means you will tolerate up to 80% gaps and 20% data in a given site.
# MY_MAX_AVG_IDENT_THRESH                    # default: 0.98.
# MY_MIN_AVG_SIMIL_THRESH                    # default: NULL, off; recommendation is 0.2?
# KEEP_ORIG_PHYLIP_SWITCH                    # default: 1, keep; alt: 0, rm orig PHYLIP file(s)
# MY_NO_GAPS_SWITCH                          # default: 0, off; 1, on.
# MY_NO_ALL_GAPS_SWITCH                      # default: 1, on; 0, off. 
# MY_LOGFILE_SWITCH=trimSeqs_log.txt         # Log file name, acts as switch to turn on loggin to file (default: on; specification would in implementation allow the user to change the name of this file, but this is not _really_ important so currently not implemented.)
# MY_VERBOSE_OUT_SWITCH=0
# MY_DEBUG_MODE_SWITCH=0

############ CREATE USAGE & HELP TEXTS
USAGE="
Usage: piranha -f $(basename "$0") [Options]...

 ${bold}Options:${reset}
  -i, --input     inputPHYLIP (def: NULL) name of input PHYLIP DNA sequence alignment file
  -m, --multi     multiPHYLIP (def: 0, turned off; 1, on) trim multiple PHYLIP files in  
                  current working directory
  -o, --output    outputFormat (def: fasta; also: phylip, nexus) Mandatory output format for 
                  trimmed alignment file(s)
  -c, --cons      consThreshold (def: 60) minimum conservation threshold (-cons), i.e. 
                  min. percentage of original sites to conserve (e.g. 60%)
  -g, --gt        gapThreshold (def: 0.2) gap threshold, given as 1 - fraction of sequences
                  with gap allowed per site
  -t, --ident     identityThreshold (def: 0.98) max. average identity threshold allowed for
                  alignments
  -s, --st        similarityThreshold (def: NULL) similarity threshold: minimum average 
                  sequence similarity allowed (recommendation: 0.2?) for sequences
  -k, --keep      keepPHYLIP (def: 1, keep; 0, on) whether or not to keep original file(s)
  -n, --nogaps    noGaps (def: 0, off; 1, on) deletes all positions with gaps in alignments
  -a, --allgaps   allGaps (def: 0, off; 1, on) deletes columns composed only of gaps
  -l, --logfile   logFile (def: trimSeqs_log.txt) log screen output to file in working dir 
                  with user-specified name (default is on, so allows changing log file name)
  -v, --verbose   verbose (def: 1, on; 0, off) output more information to screen (stdout)
  -h, --help      echo this help text and exit
  -V, --version   echo version and exit
  -d, --debug     debug (def: 0, off; 1, on) run function in Bash debug mode

 ${bold}OVERVIEW${reset}
 THIS SCRIPT automates trimming and filtering one or multiple PHYLIP (Felsenstein 2002) DNA 
 sequence alignment files using the trimAl software program (Capella-Gutiérrez et al. 2009). 
 If run with default settings, sequences will be trimmed using a conservation threshold of 
 60% and a gap threshold of 0.2, and also alignments will be screened to determine whether 
 they meet an average sequence identity threshold (-t, --ident). By default, the identity 
 threshold is set to 0.98, meaning that loci with high average identity (>98%) will be 
 filtered out of the overall dataset and placed into a discarded_alignments/ subfolder. This 
 way, only trimmed alignments that are most informative are retained (Bernardes et al. 2007).
	At least three input options should be specified by the user: 1) whether to run on one 
 (-i, --input) or multiple (-m, --multi) PHYLIP files, 2) output format (-o, --output) for 
 the trimmed alignments, and 3) identity threshold (-t, --ident). Output formats for trimmed 
 files include FASTA, PHYLIP, and NEXUS. Additionally, the program runs in the current 
 working directory and assumes that input PHYLIP files have '.phy' file extensions.
	By default, the original files are filtered out or kept, and trimmed files are saved
 to an output folder, trimal_output/. The program runs in verbose mode, with information 
 about the run output to screen, and a trimAl log (along with some stderr and stdout) for 
 each alignment is output with extension '_trimal_log.txt'. Setting the verbose option (-v,
 --verbose) to 0 makes the run quieter, with less output to screen. Optionally, the user 
 may supply their own name for an overall run log file (-l, --logfile flag), their own 
 conservation threshold (-c, --cons), gap threshold (-g, --gt), identity threshold (-t), a 
 minimum sequence similarity threshold (-s, --st), whether or not to keep the original PHYLIP 
 files (-k), to delete sites with any gaps present (-n, --nogaps), to delete sites with 
 _only_ gap characters (-a, --allgaps), or to run in debug mode (-d, --debug).
	This program runs on UNIX-like and Linux systems using commonly distributed utility 
 software, with usage as obtained by running the script with the -h flag. It has been 
 tested with Perl v5.1+ on macOS High Sierra (v10.13+) and Centos 5/6/7 Linux, but should 
 work on many other versions of macOS or Linux. Other than standard UNIX/Linux utility 
 software, the main dependency is trimAl (Capella-Gutiérrez et al. 2009), which can be 
 obtained from GitHub (available at: https://github.com/scapella/trimal). 

 ${bold}ADDITIONAL DETAILS${reset}
 ${bold}${red}*IMPORTANT*: manual and automatic modes for gap handling cannot be mixed in trimAl.${reset}
 So, if you want to specify custom conservation and gap thresholds with the -c and -g flags,
 then <noGaps> and <allGaps> must be switched off (set to 0), which is the default setting.
 For example, you could run with options '-c 60 -g 0.1' but you ${underline}cannot${reset} specify values for 
 -c and -g flags with -n 1 or -a 1. You also ${underline}cannot${reset} turn on both automatic modes, by 
 setting -n 1 and -a 1, at the same time (this would cause the run to fail).

 ${bold}Usage examples:${reset}
 Call the program using PIrANHA, as follows:

    piranha -f trimSeqs -i <inputPHYLIP>                                    Trim single <inputPHYLIP> file, with defaults
    piranha -f trimSeqs -i <inputPHYLIP> -k 0                               Same as above, but deleting original file
    piranha -f trimSeqs -m 1                                                Trim and filter multiple PHYLIP files using defaults
    piranha -f trimSeqs -m 1 -k 0                                           Trim and filter multiple PHYLIP files, while deleting
                                                                            original files
    piranha -f trimSeqs -m 1 -o phylip -t 0.99 -s 0.2                       Trim and filter multiple PHYLIP files using 
                                                                            custom identity and similarity thresholds and
                                                                            phylip output format
    piranha -f trimSeqs --multi 1 --output phylip --ident 0.99 -st 0.2      Same as above but using long option flags 
    piranha -f trimSeqs --multi 1 --ident 0.99 -st 0.2 --nogaps 1           More complete filtering options, removing sites with gaps
    piranha -f trimSeqs --multi 1 --ident 0.99 --cons 70 --gt 0.1           A run with custom gap handling options
    piranha -f trimSeqs -h                                                  Show this help text and exit

 ${bold}CITATION${reset}
 Bagley, J.C. 2020. PIrANHA v0.4a3. GitHub repository, Available at:
	<https://github.com/justincbagley/piranha>.

 ${bold}REFERENCES${reset}
 Capella-Gutiérrez, S., Silla-Martínez, J.M., and Gabaldon, T., 2009. TRIMAL: a tool for 
	automated alignment trimming in large-scale phylogenetic analyses. Bioinformatics, 25(15), 
	1972–1973.
 Felsenstein, J. 2002. PHYLIP (Phylogeny Inference Package) Version 3.6 a3.
	Available at: <http://evolution.genetics.washington.edu/phylip.html>.

 Created by Justin Bagley on Mon, Jul 27 16:37:22 CDT 2020.
 Copyright (c) 2020 Justin C. Bagley. All rights reserved.
"

if [[ -z "$*" ]]; then
	echo "$USAGE"
	exit
fi

if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
	echo "$USAGE"
	exit
fi

if [[ "$1" == "-H" ]] || [[ "$1" == "--Help" ]]; then
	echo "$VERBOSE_USAGE"
	exit
fi

if [[ "$1" == "-V" ]] || [[ "$1" == "--version" ]]; then
	echo "$(basename "$0") $VERSION";
	exit
fi

############ CHECK ARGUMENTS
	# echo "$@"; echo "$#"; echo "$1" 
	# for i in "$@"; do
	# 	echo "$i";
	# done
	# MY_ARGS="$(echo "$@" | perl -pe $'s/\ /\n/')"
	# echo "$MY_ARGS"


############ CLEAN WORKING DIR, CAPTURE ARGUMENTS, SEND TO FILE FOR PARSING
	if [[ -s ./args.tmp ]]; then rm ./args.tmp ; fi ;
	if [[ -s ./args.txt ]]; then rm ./args.txt ; fi ;
	ALL_MY_ARGUMENTS="$(echo "$@")"
	echo "$ALL_MY_ARGUMENTS" > ./args.txt
	perl -p -i -e $'s/\-/\n\-/g' ./args.txt
	perl -p -i -e $'s/\-input/\-\-input/g' ./args.txt
	perl -p -i -e $'s/\-multi/\-\-multi/g' ./args.txt
	perl -p -i -e $'s/\-output/\-\-output/g' ./args.txt
	perl -p -i -e $'s/\-gt/\-\-gt/g' ./args.txt
	perl -p -i -e $'s/\-cons/\-\-cons/g' ./args.txt
	perl -p -i -e $'s/\-logfile/\-\-logfile/g' ./args.txt
	perl -p -i -e $'s/\-st/\-\-st/g' ./args.txt
	perl -p -i -e $'s/\-keep/\-\-keep/g' ./args.txt
	perl -p -i -e $'s/\-nogaps/\-\-nogaps/g' ./args.txt
	perl -p -i -e $'s/\-allgaps/\-\-allgaps/g' ./args.txt
	perl -p -i -e $'s/\-verbose/\-\-verbose/g' ./args.txt
	perl -p -i -e $'s/\-debug/\-\-debug/g' ./args.txt


############ MANUALLY PARSE THE OPTIONS FROM ARGS

### SET OPTIONS TO DEFAULT VALUES, EXCEPT WHERE VALUES WERE READ IN FROM USER ARGS
	if [[  "$(grep -h '\-i' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-input' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		INPUT_PHYLIP_FILE=NULL ;
	elif [[  "$(grep -h '\-i' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-input' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-i' ./args.txt | perl -pe 's/\-i//g' | perl -pe 's/\ //g')";
		INPUT_PHYLIP_FILE="$MY_ARG" ;
	elif [[  "$(grep -h '\-i' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-input' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-input' ./args.txt | perl -pe 's/\-\-input//g' | perl -pe 's/\ //g')";
		INPUT_PHYLIP_FILE="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-m' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-multi' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MULTIPLE_PHYLIP_SWITCH=NULL ;
	elif [[  "$(grep -h '\-m' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-multi' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-m' ./args.txt | perl -pe 's/\-m//g' | perl -pe 's/\ //g')";
		MULTIPLE_PHYLIP_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-m' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-multi' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-multi' ./args.txt | perl -pe 's/\-\-multi//g' | perl -pe 's/\ //g')";
		MULTIPLE_PHYLIP_SWITCH="$MY_ARG" ;
	fi
#
# MY_MIN_CONS_THRESH                         # -c, --cons, default: 60, takes integer percentage of original sites to conserve.
	if [[  "$(grep -h '\-c' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-cons' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_MIN_CONS_THRESH=60 ;
	elif [[  "$(grep -h '\-c' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-cons' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-c' ./args.txt | perl -pe 's/\-c//g' | perl -pe 's/\ //g')";
		MY_MIN_CONS_THRESH="$MY_ARG" ;
	elif [[  "$(grep -h '\-c' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-cons' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-cons' ./args.txt | perl -pe 's/\-\-cons//g' | perl -pe 's/\ //g')";
		MY_MIN_CONS_THRESH="$MY_ARG" ;
	fi
#
# MY_GAP_THRESH                              # -g, --gt, default: 0.2, takes float value; 0.2 means you will tolerate up to 80% gaps and 20% data in a given site.
	if [[  "$(grep -h '\-g' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-gt' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_GAP_THRESH=0.2 ;
	elif [[  "$(grep -h '\-g' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-gt' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-g' ./args.txt | perl -pe 's/\-g//g' | perl -pe 's/\ //g')";
		MY_GAP_THRESH="$MY_ARG" ;
	elif [[  "$(grep -h '\-g' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-gt' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-gt' ./args.txt | perl -pe 's/\-\-gt//g' | perl -pe 's/\ //g')";
		MY_GAP_THRESH="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-o' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-output' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_OUTPUT_FORMAT=fasta ;
	elif [[  "$(grep -h '\-o' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-output' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-o' ./args.txt | perl -pe 's/\-o//g' | perl -pe 's/\ //g')";
		MY_OUTPUT_FORMAT="$MY_ARG" ;
	elif [[  "$(grep -h '\-o' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-output' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-output' ./args.txt | perl -pe 's/\-\-output//g' | perl -pe 's/\ //g')";
		MY_OUTPUT_FORMAT="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-s' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-st' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_MAX_AVG_IDENT_THRESH=0.98 ;
	elif [[  "$(grep -h '\-s' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-st' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-s' ./args.txt | perl -pe 's/\-s//g' | perl -pe 's/\ //g')";
		MY_MAX_AVG_IDENT_THRESH="$MY_ARG" ;
	elif [[  "$(grep -h '\-s' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-st' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-st' ./args.txt | perl -pe 's/\-\-st//g' | perl -pe 's/\ //g')";
		MY_MAX_AVG_IDENT_THRESH="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-k' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-keep' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		KEEP_ORIG_PHYLIP_SWITCH=1 ;
	elif [[  "$(grep -h '\-k' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-keep' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-k' ./args.txt | perl -pe 's/\-k//g' | perl -pe 's/\ //g')";
		KEEP_ORIG_PHYLIP_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-k' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-keep' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-keep' ./args.txt | perl -pe 's/\-\-keep//g' | perl -pe 's/\ //g')";
		KEEP_ORIG_PHYLIP_SWITCH="$MY_ARG" ;
		if [[ -z "$KEEP_ORIG_PHYLIP_SWITCH" ]] && [[ "$KEEP_ORIG_PHYLIP_SWITCH" != "0" ]] && [[ "$KEEP_ORIG_PHYLIP_SWITCH" != "1" ]]; then KEEP_ORIG_PHYLIP_SWITCH=1 ; fi
	fi
#
# MY_NO_GAPS_SWITCH                          # -n, --nogaps, default: 0, off; 1, on.
	if [[  "$(grep -h '\-n' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-nogaps' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_NO_GAPS_SWITCH=0 ;
	elif [[  "$(grep -h '\-n' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-nogaps' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-n' ./args.txt | perl -pe 's/\-n//g' | perl -pe 's/\ //g')";
		MY_NO_GAPS_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-n' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-nogaps' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-nogaps' ./args.txt | perl -pe 's/\-\-nogaps//g' | perl -pe 's/\ //g')";
		MY_NO_GAPS_SWITCH="$MY_ARG" ;
		if [[ -z "$MY_NO_GAPS_SWITCH" ]] && [[ "$MY_NO_GAPS_SWITCH" != "0" ]] && [[ "$MY_NO_GAPS_SWITCH" != "1" ]]; then MY_NO_GAPS_SWITCH=0 ; fi
	fi
#
# MY_NO_ALL_GAPS_SWITCH                      # -a, --allgaps, default: 1, on; 0, off. 
	if [[  "$(grep -h '\-a' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-allgaps' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_NO_ALL_GAPS_SWITCH=0 ;
	elif [[  "$(grep -h '\-a' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-allgaps' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-a' ./args.txt | perl -pe 's/\-a//g' | perl -pe 's/\ //g')";
		MY_NO_ALL_GAPS_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-a' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-allgaps' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-allgaps' ./args.txt | perl -pe 's/\-\-allgaps//g' | perl -pe 's/\ //g')";
		MY_NO_ALL_GAPS_SWITCH="$MY_ARG" ;
		if [[ -z "$MY_NO_ALL_GAPS_SWITCH" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" != "0" ]] && [[ "$MY_NO_ALL_GAPS_SWITCH" != "1" ]]; then MY_NO_ALL_GAPS_SWITCH=0 ; fi
	fi
#
	if [[  "$(grep -h '\-l' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-logfile' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_LOGFILE_SWITCH=trimSeqs_log.txt  ;
	elif [[  "$(grep -h '\-l' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-logfile' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-l' ./args.txt | perl -pe 's/\-l//g' | perl -pe 's/\ //g')";
		MY_LOGFILE_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-l' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-logfile' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-logfile' ./args.txt | perl -pe 's/\-\-logfile//g' | perl -pe 's/\ //g')";
		MY_LOGFILE_SWITCH="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-v' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-verbose' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_VERBOSE_OUT_SWITCH=1 ;
	elif [[  "$(grep -h '\-v' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-verbose' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-v' ./args.txt | perl -pe 's/\-v//g' | perl -pe 's/\ //g')";
		MY_VERBOSE_OUT_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-v' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-verbose' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-verbose' ./args.txt | perl -pe 's/\-\-verbose//g' | perl -pe 's/\ //g')";
		MY_VERBOSE_OUT_SWITCH="$MY_ARG" ;
		if [[ -z "$MY_VERBOSE_OUT_SWITCH" ]] && [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]] && [[ "$MY_VERBOSE_OUT_SWITCH" != "1" ]]; then MY_VERBOSE_OUT_SWITCH=1 ; fi
	fi
#
	if [[  "$(grep -h '\-d' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]] && [[  "$(grep -h '\-\-debug' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_DEBUG_MODE_SWITCH=0 ;
	elif [[  "$(grep -h '\-d' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-debug' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_ARG="$(grep -h '\-d' ./args.txt | perl -pe 's/\-d//g' | perl -pe 's/\ //g')";
		MY_DEBUG_MODE_SWITCH="$MY_ARG" ;
	elif [[  "$(grep -h '\-d' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]] && [[  "$(grep -h '\-\-debug' ./args.txt | wc -l | perl -pe 's/\ //g')" != "0" ]]; then
		MY_ARG="$(grep -h '\-\-debug' ./args.txt | perl -pe 's/\-\-debug//g' | perl -pe 's/\ //g')";
		MY_DEBUG_MODE_SWITCH="$MY_ARG" ;
		if [[ -z "$MY_DEBUG_MODE_SWITCH" ]] && [[ "$MY_DEBUG_MODE_SWITCH" != "0" ]] && [[ "$MY_DEBUG_MODE_SWITCH" != "1" ]]; then MY_DEBUG_MODE_SWITCH=1 ; fi
	fi
#

# ############# ############# #############
# ##       TIME TO RUN THE SCRIPT        ##
# ##                                     ##
# ## You shouldn't need to edit anything ##
# ## beneath this line                   ##
# ##                                     ##
# ############# ############# #############

# Trap bad exits with your cleanup function
trap trapCleanup EXIT INT TERM

# Set IFS to preferred implementation
IFS=$'\n\t'

# Exit on error. Append '||true' when you run the script if you expect an error.
set -o errexit

# Run in debug mode, if set
if ${debug}; then set -x ; fi

# Exit on empty variable
if ${strict}; then set -o nounset ; fi

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error in case mysqldump fails in `mysqldump |gzip`, for example.
set -o pipefail

# Invoke the checkDependenices function to test for Bash packages. Uncomment if needed.
# checkDependencies

# Run the script
trimSeqs

# Exit cleanly
safeExit
