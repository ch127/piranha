#!/bin/sh

##########################################################################################
#  __  o  __   __   __  |__   __                                                         #
# |__) | |  ' (__( |  ) |  ) (__(                                                        #
# |                                                                                      #
#                                                                                        #
# File: concatSeqsPartitions.sh                                                          #
  VERSION="v1.1.0"                                                                       #
# Author: Justin C. Bagley                                                               #
# Date: Created by Justin Bagley on Wed, May 8 15:48:56 CDT 2019.                        #
# Last update: April 7, 2020                                                             #
# Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved.                         #
# Please report bugs to <bagleyj@umsl.edu>.                                              #
#                                                                                        #
# Description:                                                                           #
# SHELL SCRIPT THAT CONVERTS SERIES OF PHYLIP DNA SEQUENCE ALIGNMENTS WITH THE SAME      #
# NUMBER OF TAXA INTO A SINGLE CONCATENATED PHYLIP ALIGNMENT, & ALSO PRODUCES CHARACTER  #
# SUBSET/PARTITION FILES IN RAxML, PartitionFinder, & NEXUS FORMATS, STARTING FROM A     #
# TAXON NAMES AND SPACES FILE AND WORKING DIR PATH                                       #
#                                                                                        #
##########################################################################################

# Provide a variable with the location of this script.
SCRIPT_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Source Scripting Utilities
# -----------------------------------
# These shared utilities provide many functions which are needed to provide
# the functionality in this boilerplate. This script will fail if they can
# not be found.
# -----------------------------------

UTILS_LOCATION="${SCRIPT_PATH}/../lib/utils.sh" # Update this path to find the utilities.

if [[ -f "${UTILS_LOCATION}" ]]; then
  source "${UTILS_LOCATION}"
else
  echo "Please find the file util.sh and add a reference to it in this script. Exiting..."
  exit 1
fi


# Source shared functions and variables
# -----------------------------------

FUNCS_LOCATION="${SCRIPT_PATH}/../lib/sharedFunctions.sh" # Update this path to find the shared functions.
VARS_LOCATION="${SCRIPT_PATH}/../lib/sharedVariables.sh" # Update this path to find the shared variables.

if [[ -f "${FUNCS_LOCATION}" ]] && [[ -f "${VARS_LOCATION}" ]]; then
  source "${FUNCS_LOCATION}" ;
  source "${VARS_LOCATION}" ;
else
  echo "Please find the files sharedFunctions.sh and sharedVariables.sh and add references to them in this script. Exiting... "
  exit 1
fi


# trapCleanup Function
# -----------------------------------
# Any actions that should be taken if the script is prematurely
# exited.  Always call this function at the top of your script.
# -----------------------------------
trapCleanup () {
  echo ""
  # Delete temp files, if any
  if is_dir "${tmpDir}"; then
    rm -r "${tmpDir}"
  fi
  die "Exit trapped. In function: '${FUNCNAME[*]}'"
}

# safeExit
# -----------------------------------
# Non destructive exit for when script exits naturally.
# Usage: Add this function at the end of every script.
# -----------------------------------
safeExit () {
  # Delete temp files, if any
  if is_dir "${tmpDir}"; then
    rm -r "${tmpDir}"
  fi
  trap - INT TERM EXIT
  exit
}

# Set Flags
# -----------------------------------
# Flags which can be overridden by user input.
# Default values are below
# -----------------------------------
quiet=false
printLog=false
verbose=false
force=false
strict=false
debug=false
args=()

# Set Temp Directory
# -----------------------------------
# Create temp directory with three random numbers and the process ID
# in the name.  This directory is removed automatically at exit.
# -----------------------------------
tmpDir="/tmp/${SCRIPT_NAME}.$RANDOM.$RANDOM.$RANDOM.$$"
(umask 077 && mkdir "${tmpDir}") || {
  die "Could not create temporary directory! Exiting."
}

# Logging
# -----------------------------------
# Log is only used when the '-l' flag is set.
#
# To never save a logfile change variable to '/dev/null'
# Save to Desktop use: $HOME/Desktop/${SCRIPT_BASENAME}.log
# Save to standard user log location use: $HOME/Library/Logs/${SCRIPT_BASENAME}.log
# -----------------------------------
logFile="$HOME/Library/Logs/${SCRIPT_BASENAME}.log"

# Check for Dependencies
# -----------------------------------
# Arrays containing package dependencies needed to execute this script.
# The script will fail if dependencies are not installed.  For Mac users,
# most dependencies can be installed automatically using the package
# manager 'Homebrew'.  Mac applications will be installed using
# Homebrew Casks. Ruby and gems via RVM.
# -----------------------------------
homebrewDependencies=()
caskDependencies=()
gemDependencies=()




concatSeqsPartitions () {

######################################## START ###########################################
##########################################################################################

echo "INFO      | $(date) |----------------------------------------------------------------"
echo "INFO      | $(date) | concatSeqsPartitions, v1.1.0 April 2020                        "
echo "INFO      | $(date) | Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved. "
echo "INFO      | $(date) |----------------------------------------------------------------"

######################################## START ###########################################
#if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
echo "INFO      | $(date) | Starting concatSeqsPartitions analysis... "
echo "INFO      | $(date) |          Running with the following options: "
echo "INFO      | $(date) |          - Taxon names and spaces file, <taxonNamesSpaces> = ${USER_SPEC_NAMSPACES_FILE} "
echo "INFO      | $(date) |          - Missing character option, <missingCharacter> = ${MY_MISSING_CHAR} "	# def: N
echo "INFO      | $(date) |          - <outputFile> option = ${MY_OUTPUT_FILE_SWITCH} "	# def: concatSeqsPartitions_output.txt
echo "INFO      | $(date) |          - Verbose output switch, <verbose> = ${MY_VERBOSE_OUT_SWITCH} "

echo "INFO      | $(date) | Step #1: Set up workspace and check machine type. "
#fi
############ SET WORKING DIRECTORY AND CHECK MACHINE TYPE
USER_SPEC_PATH="$(printf '%q\n' "$(pwd)")";
echoCDWorkingDir
#echo "INFO      | $(date) |          Checking machine type... "
checkMachineType
#echo "INFO      | $(date) |               Found machine type ${machine}. "

######
## START DEBUG MODE
if [[ "$MY_DEBUG_MODE_SWITCH" != "0" ]]; then set -xv; fi

if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
	echo "INFO      | $(date) | Step #2: Set output file. "
fi
if [[ "$MY_OUTPUT_FILE_SWITCH" != "NULL" ]]; then
	echo "INFO      | $(date) |          Output file switch activated. Logging output to file at ./${MY_OUTPUT_FILE_SWITCH} ... "
	echo "INFO      | $(date) |          Check the output file for additional run details ... "
	echo "----------------------------------------------------------------------------------------------------------"
	echo ""
	exec >> ./"$MY_OUTPUT_FILE_SWITCH" ;
	exec 2>&1 ;
#
	if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
		echo "INFO      | $(date) |          Output file switch activated. Logging output to file at ./${MY_OUTPUT_FILE_SWITCH} ... "
	fi
elif [[ "$MY_OUTPUT_FILE_SWITCH" = "NULL" ]]; then
	echo "INFO      | $(date) |          Default output file settings. Logging output to file at ./concatSeqsPartitions_output.txt ... "
	echo "INFO      | $(date) |          Check the output file for additional run details ... "
	echo "----------------------------------------------------------------------------------------------------------"
	echo ""
	exec >> ./concatSeqsPartitions_output.txt ;
	exec 2>&1 ;
#
	if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
		echo "INFO      | $(date) |          Default output file settings. Logging output to file at ./concatSeqsPartitions_output.txt ... "
	fi
fi


if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
	echo "INFO      | $(date) | Step #3: Run main concatSeqsPartitions function that concatenates all PHYLIP files in working dir, and makes locus/charset partitions files. "
fi
###### RUN concatSeqsPartitions FUNCTION (INCLUDES COMPLETESEQS FUNCTION AS WELL AS CODE FOR 
###### CONCATENATING PHYLIP FILES AS YOU LOOP THROUGH THEM)

count=1
(
	for i in ./*.phy; do 
 		cp "$USER_SPEC_NAMSPACES_FILE" "$i".tmp ;
 		j="$i".tmp ;
 		MY_PHYLIP_NCHAR="$(head -n1 $i | perl -pe 's/^[0-9]*\ +//g; s/\ //g')";
 		echo "###----------   $i,  $MY_PHYLIP_NCHAR bp   ----------###"

		######  concatenateSeqs  ######

		## On first loop iteration, make concatenated seqs PHYLIP file from complete locus1 
		## PHYLIP file, then make partitions/charsets files. Specifically, when you make the
		## files of RAxML partitions, PartitionFinder subsets, and NEXUS charsets, then the
		## formats are as follows:
		##      raxml format: "DNA, locus1 = 1-607"
		##      PF format: "locus1=1-607;"
		##      NEXUS format: "  charset locus1 = 1-607;" 

		if [[ "$count" = "1" ]]; then

			# Make concatenated seqs file from complete locus1 PHYLIP file, and move original
			# locus1 PHYLIP file to orig_phylip/ subfolder.
			mkdir orig_phylip/;
			cp "$i" ./concatenated_seqs.phy ;
			cp "$i" ./orig_phylip/;

			# Make partitions/charsets files with information from locus1...
			#locus="$(echo $i | perl -pe 's/\.\///g; s/\.[A-Za-z]{3,}$//g')"
			locus="$(basename $i '.phy')";
			echo "DNA, ${locus} = 1-${MY_PHYLIP_NCHAR}" >> ./raxml_partitions.part  ;
			echo "${locus}=1-${MY_PHYLIP_NCHAR};" >> partitionfinder_subsets.txt  ;
			echo "  charset ${locus} = 1-${MY_PHYLIP_NCHAR};" >> NEXUS_charsets_lowercase.txt  ;
			echo "  CHARSET ${locus} = 1-${MY_PHYLIP_NCHAR};" >> NEXUS_charsets_uppercase.txt  ;

			MY_PREV_END_RANGE_VAL="$(echo $MY_PHYLIP_NCHAR)";

		elif [[ "$count" -gt "1" ]]; then

			# Concatenate $i > 1 PHYLIP sequences to concatenated seqs PHYLIP file
			while read l; do
				MY_TAXON_NAME="$(echo $l | sed 's/\ //g')";
				MY_1ST_INST_LINE="$(grep -n "$MY_TAXON_NAME" "$i" | head -n1 | sed 's/\:.*//g; s/\ //g' | perl -pe 's/\t//g')";		
					# extract/copy corresponding sequence from $i and paste it to end of
					# line with same name ($MY_TAXON_NAME) in tmp file $j:
					MY_SEQUENCE="$(grep -h "$MY_TAXON_NAME" $i | perl -pe 's/^[A-Za-z0-9\-\_\ ]*\ //g' | sed 's/\ //g')";
					if [[ "${machine}" = "Mac" ]]; then
						sed -i.bak '/^'"$MY_TAXON_NAME"'/s/$/'"$MY_SEQUENCE"'/' ./concatenated_seqs.phy  ;
						rm ./*.bak;
					fi

					if [[ "${machine}" = "Linux" ]]; then
						sed -i '/^'"$MY_TAXON_NAME"'/s/$/'"$MY_SEQUENCE"'/' ./concatenated_seqs.phy  ;
					fi
			done < "$USER_SPEC_NAMSPACES_FILE"

			# Add ith locus information to partitions/charsets files...
			locus="$(basename $i '.phy')";
			MY_NEW_START_RANGE_VAL="$(calc $MY_PREV_END_RANGE_VAL + 1)";
			MY_NEW_END_RANGE_VAL="$(calc $MY_PREV_END_RANGE_VAL + $MY_PHYLIP_NCHAR)";
			echo "DNA, ${locus} = $MY_NEW_START_RANGE_VAL-${MY_NEW_END_RANGE_VAL}" >> ./raxml_partitions.part  ;
			echo "${locus}=$MY_NEW_START_RANGE_VAL-${MY_NEW_END_RANGE_VAL};" >> partitionfinder_subsets.txt  ;
			echo "  charset ${locus} = $MY_NEW_START_RANGE_VAL-${MY_NEW_END_RANGE_VAL};" >> NEXUS_charsets_lowercase.txt  ;
			echo "  CHARSET ${locus} = $MY_NEW_START_RANGE_VAL-${MY_NEW_END_RANGE_VAL};" >> NEXUS_charsets_uppercase.txt  ;

			MY_PREV_END_RANGE_VAL="$(echo $MY_NEW_END_RANGE_VAL)";

			cp "$i" ./orig_phylip/ ;

		fi

	echo "$((count++))" > count.tmp ;
		
	done
)


###### FIX NEW CONCATENATED PHYLIP ALIGNMENT TO HAVE THE CORRECT NCHAR INFORMATION

		# Add header with corrected ntax and nchar information:
		cat ./concatenated_seqs.phy | tail -n+2 > ./concatenated_seqs.tmp  ;
		MY_CONCAT_PHY_NTAX="$(cat ./concatenated_seqs.phy | tail -n+2 | wc -l | perl -pe 's/\t//g; s/\ //g')";
		MY_CONCAT_PHY_NCHAR="$(head -n2 ./concatenated_seqs.phy | tail -n1 | perl -pe 's/^[A-Za-z0-9\-\_]*[\ ]*//; s/\ //g; s/$//g; s/\s//g' | wc -c | perl -pe 's/\t//g; s/\ //g')"
		echo "$MY_CONCAT_PHY_NTAX  $MY_CONCAT_PHY_NCHAR" > ./concat_header.tmp   ;
		
		# Overwrite original phy file with new phy file:
		cat ./concat_header.tmp ./concatenated_seqs.tmp > ./concatenated_seqs.phy  ;


if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
	echo "INFO      | $(date) | Step #4: Clean up workspace by removing temporary files generated during run. "
	echo "INFO      | $(date) |          Deleting temporary files... "
fi
############ CLEAN UP WORKING DIR BY DELETING TEMPORARY FILES.
	
	if [[ ! -z ./*.tmp ]]; then rm ./*.tmp ; fi
	if [[ -s ./args.txt ]]; then rm ./args.txt ; fi 	## Remove arguments file generated when parsing the options.


echo "----------------------------------------------------------------------------------------------------------"
echo "output file(s): ./concatenated_seqs.phy "
#if [[ "$MY_VERBOSE_OUT_SWITCH" != "0" ]]; then
#	echo "output file(s): ./concatenated_seqs.phy "
#fi
echo ""

## END DEBUG MODE
if [[ "$MY_DEBUG_MODE_SWITCH" != "0" ]]; then set +xv; fi
######

##########################################################################################
######################################### END ############################################

}



############ CREATE USAGE & HELP TEXTS
USAGE="Usage: $(basename "$0") [OPTION]...

 ${bold}Options:${reset}
  -t   taxonNamesSpaces (def: NULL) mandatory name of taxon 'names and spaces' file
  -o   outputFile (def: NULL) send screen output to file in working dir with user-specified 
       name, for example 'output.txt'
  -v   verbose (def: 0, off; 1, on) specify verbose run, step output to screen (stdout),
       logged to output file
  -h   help text (also: --help) echo this help text and exit
  -V   version (also: --version) echo version of this script and exit
  -d   debug (def: 0, off; 1, on also: --debug) run function in Bash debug mode

 ${bold}OVERVIEW${reset}
 THIS FUNCTION is designed to run in a working directory containing a series of PHYLIP 
 (Felsenstein 2002) DNA sequence alignments for different genes (e.g. 100s or 1000s of RAD 
 or UCE loci) with the same number of taxa. Given such a workspace, this script takes as 
 input (-t flag) a 'names and spaces file', <taxonNamesSpaces>, containing only the names of 
 tip taxa, one per line, as well as spaces extending the total number of characters to be 
 the same on each line (e.g. 10 or 12 characters including spaces). The program concatenates 
 all of the input PHYLIP files into a single, concatenated PHYLIP alignment. The ordering of 
 the gene alignments is equal to the alphanumeric order in which bash or UNIX terminal would 
 read the PHYLIP files (e.g. locus1.phy, locus10.phy, ..., and not locus1.phy, locus2.phy, 
 ...). While looping through the PHYLIP files, the program also uses their headers to make 
 partitions/charsets files with RAxML partition, PartitionFinder subset, and NEXUS charset 
 formats. Results are output to multiple partitions files.
	By default script output is written to a file named 'concatSeqsPartitions_output.txt'. 
 The user may optionally specify verbose output (-v 1) or a desired output file name (using
 the -o flag). Taxon names in the PHYLIP files should contain only alphanumeric characters  
 and no spaces, or else there could be issues. Also, PHYLIP alignments must have the '.phy'
 extension.
	This program runs on UNIX-like and Linux systems using commonly distributed utility 
 software, with usage obtained by running the script with the -h flag. It has been tested
 on macOS High Sierra (v10.13+) and Mojave but should work on many earlier versions or
 Linux (tested on CentOS 6/7). Besides standard UNIX/Linux command line tools, the only other 
 dependency is Perl (v5+), which is usually already installed on mac and Linux distributions.

 ${bold}Usage examples:${reset}
 To run using current directory as <workingDir> with a names and spaces text file named 
 'taxon_name_spaces12.txt' containing each tip taxon name followed by x number of spaces 
 taking the total character count per line out to 12 characters, you would call the program 
 using PIrANHA as follows:

    piranha -f concatSeqsPartitions --args='-t taxon_name_spaces12.txt'

 ${bold}CITATION${reset}
 Bagley, J.C. 2019. PIrANHA v0.3a2. GitHub repository, Available at:
	<https://github.com/justincbagley/piranha>.

 ${bold}REFERENCES${reset}
 Felsenstein, J. 2002. PHYLIP (Phylogeny Inference Package) Version 3.6a3.
	Available at: <http://evolution.genetics.washington.edu/phylip.html>.

 Created by Justin Bagley on Wed, May 8 15:48:56 CDT 2019.
 Copyright (c) 2019-2020 Justin C. Bagley. All rights reserved.
"

if [[ -z "$*" ]]; then
	echo "$USAGE"
	exit
fi

if [[ "$1" == "-h" ]] || [[ "$1" == "-help" ]]; then
	echo "$USAGE"
	exit ;
fi

if [[ "$1" == "-V" ]] || [[ "$1" == "--version" ]]; then
	echo "$(basename $0) $VERSION"
	exit ;
fi

############ CHECK ARGUMENTS
	# echo "$@"; echo "$#"; echo "$1" 
	# for i in "$@"; do
	# 	echo "$i";
	# done
	# MY_ARGS="$(echo "$@" | perl -pe $'s/\ /\n/')"
	# echo "$MY_ARGS"


############ CAPTURE ARGUMENTS, SEND TO FILE FOR PARSING
	if [[ -s ./args.tmp ]]; then rm ./args.tmp ; fi ;
	if [[ -s ./args.txt ]]; then rm ./args.txt ; fi ;

	ALL_MY_ARGUMENTS="$(echo "$@")"
	echo "$ALL_MY_ARGUMENTS" > ./args.txt
	perl -p -i -e $'s/\-/\n\-/g' ./args.txt
	#perl -p -i -e $'s/\ /\n/g' ./args.txt
	#wc -l ./args.txt | perl -pe 's/\.\/args\.txt.*//g' | perl -pe 's/\ //g'


############ MANUALLY PARSE THE OPTIONS FROM ARGS

### SET OPTIONS TO DEFAULT VALUES, EXCEPT WHERE VALUES WERE READ IN FROM USER ARGS
	if [[  "$(grep -h '\-t' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		USER_SPEC_NAMSPACES_FILE=NULL ;
	else 
		MY_ARG="$(grep -h '\-t' ./args.txt | perl -pe 's/\-t//g' | perl -pe 's/\ //g')";
		USER_SPEC_NAMSPACES_FILE="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-o' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_OUTPUT_FILE_SWITCH=NULL ;
	else 
		MY_ARG="$(grep -h '\-o' ./args.txt | perl -pe 's/\-o//g' | perl -pe 's/\ //g')";
		MY_OUTPUT_FILE_SWITCH="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-v' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_VERBOSE_OUT_SWITCH=0 ;
	else 
		MY_ARG="$(grep -h '\-v' ./args.txt | perl -pe 's/\-v//g' | perl -pe 's/\ //g')";
		MY_VERBOSE_OUT_SWITCH="$MY_ARG" ;
	fi
#
	if [[  "$(grep -h '\-d' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_DEBUG_MODE_SWITCH=0 ;
	else 
		MY_ARG="$(grep -h '\-d' ./args.txt | perl -pe 's/\-d//g' | perl -pe 's/\ //g')";
		MY_DEBUG_MODE_SWITCH="$MY_ARG" ;
	fi
	if [[  "$(grep -h '\-\-debug' ./args.txt | wc -l | perl -pe 's/\ //g')" = "0" ]]; then
		MY_DEBUG_MODE_SWITCH=0 ;
	else 
		MY_DEBUG_MODE_SWITCH=1 ;
	fi


# ############# ############# #############
# ##       TIME TO RUN THE SCRIPT        ##
# ##                                     ##
# ## You shouldn't need to edit anything ##
# ## beneath this line                   ##
# ##                                     ##
# ############# ############# #############

# Trap bad exits with your cleanup function
trap trapCleanup EXIT INT TERM

# Set IFS to preferred implementation
IFS=$'\n\t'

# Exit on error. Append '||true' when you run the script if you expect an error.
set -o errexit

# Run in debug mode, if set
if ${debug}; then set -x ; fi

# Exit on empty variable
if ${strict}; then set -o nounset ; fi

# Bash will remember & return the highest exitcode in a chain of pipes.
# This way you can catch the error in case mysqldump fails in `mysqldump |gzip`, for example.
set -o pipefail

# Invoke the checkDependenices function to test for Bash packages.  Uncomment if needed.
# checkDependencies

# Run the script
concatSeqsPartitions

# Exit cleanly
safeExit
